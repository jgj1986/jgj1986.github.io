<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="author" content="jgj" />
        <meta name="viewport" content="width=device-width" /> 
        <title>记录生活工作中的点滴 | 我是疯子</title>
        

        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- bootstrap source -->
        <!-- 新 Bootstrap 核心 CSS 文件 -->
        <link rel="stylesheet" href="http://cdn.bootcss.com/bootstrap/3.2.0/css/bootstrap.min.css" />
        <!-- 可选的Bootstrap主题文件（一般不用引入） -->
        <link rel="stylesheet" href="http://cdn.bootcss.com/bootstrap/3.2.0/css/bootstrap-theme.min.css" />
        <!-- jQuery文件。务必在bootstrap.min.js 之前引入 -->
        <script src="http://cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>
        <!-- 最新的 Bootstrap 核心 JavaScript 文件 -->
        <script src="http://cdn.bootcss.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>

        <link rel="stylesheet" href="/asset/css/kissdata.css" />

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
            <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <link href="/feed.html" rel="alternate" title="jgj" type="application/atom+xml" />
        <link rel="shortcut icon" href="/favicon.ico" />
        <link rel="icon" href="/favicon.ico" />

        <style type="text/css">
            body {
                padding-top: 55px;
                padding-bottom: 30px;
                background-color: #EEE;
            }
        </style>

        <link rel="stylesheet" href="/asset/js/google-code-prettify/prettify.css">
        <script src="/asset/js/google-code-prettify/prettify.js"></script>

        <script type="text/javascript">
            $(document).ready(function () {

                // go to top
                var bt = $('#toolBackTop'); var sw = $(document.body)[0].clientWidth; var limitsw = (sw - 840) / 2 - 80; if (limitsw > 0){ limitsw = parseInt(limitsw); bt.css("right",limitsw); } $(window).scroll(function() { var st = $(window).scrollTop(); if(st > 30){ bt.show(); }else{ bt.hide(); } });

                // google-code-prettify
                $("pre").addClass("prettyprint linenums"); prettyPrint();

            })
        </script>

        <!-- kp747 
        
        -->
    </head>
    <body>
            <div id="header">
    <!-- Fixed navbar -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand normal-a" href="javascript:void(0)" onclick="javascript:void(0)">
                    <span id="site_name">我是疯子</span>
                </a>
            </div>

            <div id="navbar" class="navbar-collapse collapse">
                <ul class="nav navbar-nav">
                    <li><a href="/">首页</a></li>
                    <li><a href="/categories.html">分类</a></li>
                    <li><a href="/guestbook.html">留言</a></li>
                    <li><a href="/about.html">关于</a></li>
                    <li><a href="/feed.html">RSS</a></li>
                    <li><a href="javascript:void(0)" class="normal-a" onclick="javascript:void(0)"><span id="site_description">在此停留片刻，偶有所得！</span></a></li>
                </ul>
            </div><!--/.nav-collapse -->
        </div>
    </nav>
</div>


            <div class="container">
                <div class="row">
                    <div class="col-md-9" id="main-left">
                        <h1>记录生活工作中的点滴</h1>

<hr class="small-margin" />

<div>
    
    <div class="post-card">
        <div class="head"><a href="/2016/03/04/Hadoop_Namenode.html"><span class="title">Hadoop_namenode</span></a><span class="date">2016-03-04</span></div>
        <div class="content"><ul id="markdown-toc">
  <li><a href="#hdfs-ha-">hdfs HA 配置</a></li>
  <li><a href="#section">不同</a></li>
</ul>

<h2 id="hdfs-ha-">hdfs HA 配置</h2>

<p>现在的hadoop集群支持高可用性(High Availability)的配置，主要表现在在支持两个namenode (和Secondary NameNode有什么不同呢？)
参考 <a href="http://www.itdadao.com/article/234754/" target="_blank">hadoop HA配置文件说明</a>，可知在hdfs-site.xml 中，添加两个上dfs.ha.namenodes.mycluster，支持rpc和http的监听端口，如下：</p>

<pre><code>&lt;property&gt;
  &lt;name&gt;dfs.ha.namenodes.mycluster&lt;/name&gt;
  &lt;value&gt;nn1,nn2&lt;/value&gt;
&lt;/property&gt;

&lt;property&gt;
  &lt;name&gt;dfs.namenode.rpc-address.mycluster.nn1&lt;/name&gt;
  &lt;value&gt;machine1:8020&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;dfs.namenode.rpc-address.mycluster.nn2&lt;/name&gt;
  &lt;value&gt;machine2:8020&lt;/value&gt;
&lt;/property&gt;

&lt;property&gt;
  &lt;name&gt;dfs.namenode.http-address.mycluster.nn1&lt;/name&gt;
  &lt;value&gt;machine1:50070&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;dfs.namenode.http-address.mycluster.nn2&lt;/name&gt;
  &lt;value&gt;machine2:50070&lt;/value&gt;
&lt;/property&gt;
</code></pre>

<p>到时候在machine1 和machine2 上都启动namenode服务即可。在最开始启动服务的时候，多采用如下的执行过程</p>

<pre><code>machine1&gt; hdfs  namenode  –format
machine1&gt; hadoop-daemon.sh  start namenode
machine2&gt; hdfs namenode  -bootstrapStandby
machine2&gt; hadoop-daemon.sh  start  namenode
</code></pre>

<p>正常启动的话，machine1:50070 和 machine2:50070 都可在浏览器下访问。</p>

<h2 id="section">不同</h2>

<p>那 HA 使用的namenode(备用的Standby NameNode) 和 Secondary NameNode 有什么不同呢， 看看
<a href="https://www.quora.com/What-is-the-difference-between-a-standby-NameNodes-and-a-secondary-NameNode-Does-the-new-Hadoop-with-YARN-have-a-secondary-NameNode" target="_blank">这篇文章</a>。</p>

<p>Secondary Namenode是将日志和镜像文件合到一起(然后namenode加载到ram中)，不具有容错功能；如果Namenode一旦出错，可能就要人工干预了; <br />
而HA环境的Standby Namenode则提供了自动的容错功能。HA不是强制性的，但使用了HA，就不要在使用SecondayNamenode了。</p>

<p>原文：</p>

<p>Secondary Namenode: 
In Hadoop 1.x and 2.x, the secondary namenode means the same. It does CPU intensive tasks for Namenode. In more details, it combines the Edit log and fs_image and returns the consolidated file to Namenode. Namenode then loads that file into RAM. But, secondary namenode doesn’t provide failover capabilities.  So, in case of Namenode failure, Hadoop admins have to manually recover the data from Secondary Namenode.</p>

<p>Now, what’s Standby Namenode?
In Hadoop 2.0, with the introduction of HA, the Standby Namenode came into picture. The standby namenode is the node that removes the problem of SPOF (Single Point Of Failure) that was there in Hadoop 1.x. The standby namenode provides automatic failover in case Active Namenode (can be simply called ‘Namenode’ if HA is not enabled) fails. </p>

<p>Moreover, enabling HA is not mandatory. But, when it is enabled, you can’t use Secondary Namenode. So, either Secondary Namenode is enabled OR Standby Namenode is enabled. </p>

</div>
        <div class="more text-right"><a href="/2016/03/04/Hadoop_Namenode.html">继续阅读全文</a></div>
    </div>
    
    <div class="post-card">
        <div class="head"><a href="/2015/12/29/bash%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A71229.html"><span class="title">Bash使用小技巧1229</span></a><span class="date">2015-12-29</span></div>
        <div class="content"><ul id="markdown-toc">
  <li><a href="#string-">string 去掉空格</a></li>
  <li><a href="#section">字符串的切割</a></li>
  <li><a href="#sql-">sql 拼接</a></li>
  <li><a href="#mysql">mysql</a></li>
</ul>

<blockquote>
  <p>这两天编写了个脚本，将老版本的sql转为新版本的sql，过程中有一些细节还是值得记录一下的</p>
</blockquote>

<h2 id="string-">string 去掉空格</h2>

<pre><code>$ str=" hello world "
$ echo "#${str//[[:blank:]]}/#"
#helloworld#
</code></pre>

<h2 id="section">字符串的切割</h2>

<p>该方法很早就用到了，但是之前主要是做路径的切割，使用了 <code>'/'</code>字符，其实可以使用字符串的</p>

<pre><code>$ sql="select id,name from students where id&gt;1"
$ echo ${sql%from*}
select id,name
$ echo ${sql#*from}
students where id&gt;1
</code></pre>

<h2 id="sql-">sql 拼接</h2>

<p>在生成的sql的字段中本身就还有单引号，如果要顺利执行这些sql语句，可以将单个单引号转为两个单引号</p>

<pre><code>sql=`echo "$select from $condition" | sed -e "s/'/''/g"`
$MYSQL -e "$sql"
</code></pre>

<h2 id="mysql">mysql</h2>

<p>mysql  -s slient，不显示头部
       -t tab  table的格式输出</p>

<p>如果既有-t，又有-s呢，-s的效果就被覆盖了    </p>

</div>
        <div class="more text-right"><a href="/2015/12/29/bash%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A71229.html">继续阅读全文</a></div>
    </div>
    
    <div class="post-card">
        <div class="head"><a href="/2015/12/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2.html"><span class="title">字符编码转换</span></a><span class="date">2015-12-25</span></div>
        <div class="content"><ul id="markdown-toc">
  <li><a href="#iconv">iconv</a></li>
  <li><a href="#uni2asciiascii2uni">uni2ascii/ascii2uni</a></li>
</ul>

<blockquote>
  <p>iconv 好用，但是也有短处</p>
</blockquote>

<h2 id="iconv">iconv</h2>

<p>因为Linux与Windows默认的编码不同，所以文件在两者间相互使用的时候就需要有些编码的转换，而iconv 工具比较好用，如：</p>

<pre><code>$ iconv -f gbk -t utf-8 inputfile &gt; outputfile
</code></pre>

<p>命令将inputfile文件做转码，从gbk转为utf-8。</p>

<h2 id="uni2asciiascii2uni">uni2ascii/ascii2uni</h2>

<p>但是在实际的场景中，却存在很多unicode的字符，使用 <code>file</code> 命令查看文件是 ascii 或 ascii utf-8 的文件类型，对于这</p>

<p>种文件，使用</p>

<pre><code>$ iconv -f unicode -t utf-8 inputfile &gt; outputfile
</code></pre>

<p>是不能有效转码的，而使用 <code>uni2ascii/ascii2uni</code> 则可以达到这个目的</p>

<pre><code>$ echo "圣诞快乐" | uni2ascii -a U -q
\u5723\u8BDE\u5FEB\u4E50
$ echo "\u5723\u8BDE\u5FEB\u4E50" | ascii2uni -a U -q
圣诞快乐
</code></pre>

</div>
        <div class="more text-right"><a href="/2015/12/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2.html">继续阅读全文</a></div>
    </div>
    
    <div class="post-card">
        <div class="head"><a href="/2015/12/24/%E5%87%A0%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AF%94%E8%BE%83.html"><span class="title">几个数据库比较</span></a><span class="date">2015-12-24</span></div>
        <div class="content"><ul id="markdown-toc">
  <li><a href="#section">资源占用</a></li>
  <li><a href="#section-1">速度</a></li>
  <li><a href="#section-2">实际使用</a></li>
  <li><a href="#rocksdb">rocksdb</a></li>
  <li><a href="#section-3">资料</a></li>
</ul>

<blockquote>
  <p>在统计的实现过程中用到了Redis、LevelDB 和 SSDB，对这三者，有必要好好的统计分析下</p>
</blockquote>

<h2 id="section">资源占用</h2>

<p>Redis 是要一直存在内存中的，当然如果有必要，也可flush回磁盘，需要的时候在download进内存，但是过程比较长，而且不是redis的正道。
相对而言leveldb和ssdb就是将数据存储在磁盘上，需要时才会将需要的部分load进内存中，所以对内存的要求比较低。</p>

<h2 id="section-1">速度</h2>

<p>Redis的资源都在内存中，请求的相依速度会比较快。每次请求方式都是以网络形式进行，会带来一定的时间消耗。
leveldb和ssdb的读写都是磁盘的上的操作，相比redis，速度肯定会降低一些。</p>

<h2 id="section-2">实际使用</h2>

<p>在实际的统计分析时，当数据量比较大的时候，且Redis的交互比较频繁的时候，发现Redis的读写请求也成了性能瓶颈，完全没有达到预期。
为此，采用新leveldb存储的方式，在统计时，将数据完全load到内存中，在进行读写操作（包括判断）时，直接和内存进行交互，从而大大提高了速度。
但是这样有一个问题，就是随着时间的推移，保留的历史数据会越来越多，需要的内存就会越来越大。
在此过程中还有个问题，如果程序被非法中断，可能会导致leveldb数据的破坏，导致下次load会失败。</p>

<p>后续了解到，在BI的reduce过程中，使用ssdb做判断（因为集群能力还是有限，将一些计算从Hive前移到MR中）。
这儿通过一些措施来减少ssdb可能带来的影响：1.根据日志的类型ssdb做了不同的库；2.map过程将同样的key整合在了一起，减少ssdb的交互次数。</p>

<h2 id="rocksdb">rocksdb</h2>

<p>redis、leveldb已经比较多的使用到很多地方了，从<a href="http://ssdb.io/" target="_blank">官网</a>上了解到ssdb也已经在很多公司中使用了。
现在能搜到Facebook开源的RocksDB，说是更加彪悍，通过下面的一个<a href="https://influxdb.com/blog/2014/06/20/leveldb_vs_rocksdb_vs_hyperleveldb_vs_lmdb_performance.html" target="_blank">性能比较</a>，发现还是各有千秋，rocksdb在读写删除等上确实是快了一些。。</p>

<h2 id="section-3">资料</h2>

<p><a href="http://ssdb.io/docs/zh_cn/" target="_blank">ssdb 中文文档</a>;<br />
<a href="https://influxdb.com/blog/2014/06/20/leveldb_vs_rocksdb_vs_hyperleveldb_vs_lmdb_performance.html" target="_blank">leveldb/rocksdb/HyperLevelDB/LMDB性能对比</a>;</p>

</div>
        <div class="more text-right"><a href="/2015/12/24/%E5%87%A0%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AF%94%E8%BE%83.html">继续阅读全文</a></div>
    </div>
    
    <div class="post-card">
        <div class="head"><a href="/2015/12/14/nginx_https.html"><span class="title">Nginx_https</span></a><span class="date">2015-12-14</span></div>
        <div class="content"><ul id="markdown-toc">
  <li><a href="#section">基本配置</a></li>
  <li><a href="#https">https服务端优化</a></li>
  <li><a href="#ssl">ssl证书链</a></li>
  <li><a href="#httphttps-">HTTP/HTTPS 服务</a></li>
  <li><a href="#https-1">基于名字的HTTPS服务</a></li>
  <li><a href="#section-1">一个证书多个域名</a></li>
  <li><a href="#section-2">其他</a></li>
</ul>

<blockquote>
  <p>因为ios9要求使用https，而现在的服务又需要http的支持，需要对nginx中配置使用https需要有些更深入的了解。nginx官网上 <a href="http://nginx.org/en/docs/http/configuring_https_servers.html" taget="_blank">nginx配置htpps服务</a>，说的比较透彻，此文做简单的意译。</p>
</blockquote>

<h2 id="section">基本配置</h2>

<p>要使用https服务，那服务端比较要有相应的配置：监听的socket上支持ssl，指定服务证书和私钥。https使用的443端口，如果我们用443端口作为入口并设置监听，则在浏览器https后的地址栏就看不到443端口。</p>

<pre><code>server {
    listen              443 ssl;
    server_name         www.example.com;
    ssl_certificate     www.example.com.crt;
    ssl_certificate_key www.example.com.key;
    ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers         HIGH:!aNULL:!MD5;
    ...
}
</code></pre>

<p>服务端证书 <code>ssl_certificate</code> 是公开的，会发送到连接服务端的各个客户端；私钥 <code>ssl_certificate_key</code>是保密的，访问权限受限（nginx的主进程可读）。上面还用的了 <code>ssl_protocals</code> 和 <code>ssl_ciphers</code> ，这个不是必须的。</p>

<h2 id="https">https服务端优化</h2>

<p>ssl会消耗CPU资源，而CPU使用最重的是ssl的握手过程，有两个方法来减少这些握手过程：1，允许连接的keepalive，使用一个连接回复过个相应；2，在并行和随后的连接中复用ssl的会话参数(session parameters)，从而避免ssl的再握手。我们可以将这些默认的配置调整达到优化目的。</p>

<pre><code>worker_processes auto;

http {
   ssl_session_cache   shared:SSL:10m; # 4000 -&gt; 10M
    ssl_session_timeout 10m;           # 5 minutes -&gt; 10m

    server {
        listen              443 ssl;
        server_name         www.example.com;
        keepalive_timeout   70;        # use this

        ssl_certificate     www.example.com.crt;
    ...
</code></pre>

<h2 id="ssl">ssl证书链</h2>

<p>你可能会遇到一些浏览器对证书没有问题，而一些浏览器会提示证书可能存在风险，即使证书是由知名的证书机构签发的。这是因为签发的多个服务证书(server certificate)使用了一个中间证书(intermediate certificate)，而这中间证书没有在当前随受信任证书一起提供到浏览器中。在这种情况下，签发机构提供了一个大包的链路证书(chained certificates)用来合到单一的服务证书中。</p>

<pre><code>$ cat www.example.com.crt bundle.crt &gt; www.example.com.chained.crt
</code></pre>

<p>在服务配置中就使用这个新的服务证书<code>www.example.com.chained.crt</code>。注意，服务证书要在前面，否则就会出现这样的错误信息</p>

<pre><code>SSL_CTX_use_PrivateKey_file(" ... /www.example.com.key") failed
   (SSL: error:0B080074:x509 certificate routines:
    X509_check_private_key:key values mismatch)
</code></pre>

<p>原文此处还有具体解析过程的说明，本文忽略。</p>

<h2 id="httphttps-">HTTP/HTTPS 服务</h2>

<p>也可以配置一个服务支持HTTP 和 HTTPS 请求：</p>

<pre><code>server {
    listen              80;
    listen              443 ssl;
    server_name         www.example.com;

    ssl_certificate     www.example.com.crt;
    ssl_certificate_key www.example.com.key;
    ...
}
</code></pre>

<p>:-) 这个就是在用户系统中想要的。</p>

<h2 id="https-1">基于名字的HTTPS服务</h2>

<p>在单个ip上实现两个或多个https服务时，就会有个常见问题。假设我们如下配置</p>

<pre><code>server {
    listen          443 ssl;
    server_name     www.example.com;
    ssl_certificate www.example.com.crt;
    ...
}
</code></pre>

<p>server {
    listen          443 ssl;
    server_name     www.example.org;
    ssl_certificate www.example.org.crt;
    …
}</p>

<p>受ssl协议的影响，会先建立ssl连接，然后在有http的请求，所以在使用https请求时，不知道使用哪个证书，只好使用默认的服务证书了。一个古老而最鲁棒的解决办法就是安置到不同的ip地址上</p>

<pre><code>server {
    listen          192.168.1.1:443 ssl;
    server_name     www.example.com;
    ssl_certificate www.example.com.crt;
    ...
}

server {
    listen          192.168.1.2:443 ssl;
    server_name     www.example.org;
    ssl_certificate www.example.org.crt;
    ...
}
</code></pre>

<h2 id="section-1">一个证书多个域名</h2>

<p>可以支持一个IP多个域名的https，但是都有些缺点。还有一个方式，就是使用同一份证书，支持多个域名</p>

<pre><code>ssl_certificate     common.crt;
ssl_certificate_key common.key;

server {
    listen          443 ssl;
    server_name     www.example.com;
    ...
}

server {
    listen          443 ssl;
    server_name     www.example.org;
    ...
}
</code></pre>

<h2 id="section-2">其他</h2>

<p>本文忽略，请查看原文。</p>

</div>
        <div class="more text-right"><a href="/2015/12/14/nginx_https.html">继续阅读全文</a></div>
    </div>
    
    <div class="post-card">
        <div class="head"><a href="/2015/12/02/heka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html"><span class="title">Heka源码阅读</span></a><span class="date">2015-12-02</span></div>
        <div class="content"><ul id="markdown-toc">
  <li><a href="#section">大体流程</a></li>
  <li><a href="#section-1">加载配置文件</a></li>
  <li><a href="#section-2">启动与关闭</a></li>
  <li><a href="#section-3">数据的传递</a></li>
</ul>

<blockquote>
  <p>使用heka已经一段时间了，而里面的逻辑还是很有必要看看的。</p>
</blockquote>

<h2 id="section">大体流程</h2>

<pre><code>main (cmd/hekad/main.go)
 |  LoadHekadConfig (cmd/hekad/conf.go)
 |  setGlobalConfigs
 |  loadFullConfig
 |  LoadFromConfigFile (pipeline/config.go)
 |  Run(pipeline/pipeline_runner.go)
</code></pre>

<p>可以大体看出，加载配置文件，设置为一些全局的变量，生成相关的input、output、decoder、encoder、filter等，然后启动这些插件。</p>

<h2 id="section-1">加载配置文件</h2>

<p>加载配置文件，主要是将制定目录下的 .toml 文件 或制定的配置文件读到内存，先设置一些全局的配置如 cpu 等；然后逐个处理每个插件。</p>

<p>先做Pre-loading，判断插件是不是已经注册过的插件。这儿需要说明，使用 AvailablePlugins 来存放已经注册的插件，RegisterPlugin 函数实现后端的注册功能。 在Pre-Loading过程中，会将插件按照 Input、Output、Filter 等分到不同的组中，用于后面不同顺序启动。实际过程是调用 <code>NewPluginMaker</code> 来创建对应的插件制造者(PluginMaker)。</p>

<p>有两个特殊的插件 <code>ProtobufEncoder</code> 和 <code>ProtobufDecoder</code>，即使在没有配置的情况下也要启动。</p>

<p>接下来是Loading过程：分别去除 “Decoder”, “Encoder”, “Input”, “Filter”, “Output” 组中的pluginMaker，调用其 MakerRunner()得到相应的runner，放到不同的Runners组中。
在MakerRunner函数中，会根据类型的不同，生成不同的runner，如NewInputRunner、NewFORunner 等，这些构造函数在 pipeline/plugin_runners.go 中实现。需要说明的一点，在xxRunner的类型都定义了自己的函数，比如Start(调用Starter)函数会调用插件的 <code>Run</code>方法，所以在后续调用每个runner的Start 方法时，即调用了插件的Run方法。encode和decode插件，实现对应的Encode 和 Decode方法，而不是Run方法。</p>

<h2 id="section-2">启动与关闭</h2>

<p>pipeline_runner.go 中的 <code>Run</code>函数实现了heka的插件启动、监控、退出功能。</p>

<p>先依次启动 output、filter的插件，然后是一些heka自己的初始化，router.initMatchSlices、启动diagnostic trackers、config.router.Start，然后在启动input相关的插件。插件的启动，即调用插件的Start即Run方法。
插件都正常启动运行后，heka主线程就是等待退出信号，当有退出信号时，按照启动相反的顺序，停止 input、decode、filter、output、encode，即调用stop()方法。</p>

<h2 id="section-3">数据的传递</h2>

<p>该过程中，消息又是如何从 input一步步的传递到output中的呢？是什么要的机制保证heka能有如此高的传递速度的呢？</p>

<p>在 《go语言编程》中有实现管道的一段简单例子，</p>

<pre><code>type PipeData struct {
    value int
    handler func(int) int
    next chan int
}

func handle(queue chan *PipeData) {
    for data := range queue {
        data.next &lt;- data.handler(data.value)
    }
}
</code></pre>

<p>其基本逻辑也就是，在入口端接收到消息，做相应的处理后，写入到对应的下一个channel中。有了这样的基础知识，我们来看 <code>config.router.Start()</code> (pipeline/router.go)，有这样的一段实现</p>

<pre><code>select {
    case ...
    ...

        case pack, ok = &lt;-self.inChan:
            if !ok {
                break
            }
            pack.diagnostics.Reset()
            atomic.AddInt64(&amp;self.processMessageCount, 1)
            for _, matcher = range self.fMatchers {
                if matcher != nil {
                    atomic.AddInt32(&amp;pack.RefCount, 1)
                    matcher.inChan &lt;- pack
                }
            }
            for _, matcher = range self.oMatchers {
                if matcher != nil {
                    atomic.AddInt32(&amp;pack.RefCount, 1)
                    matcher.inChan &lt;- pack
                }
            }
            pack.Recycle()
        }
...
</code></pre>

<p>也就是，当自己inChan中有数据到达的时候，会和matcher做判断，匹配的情况下，就会将数据传到matcher的 inChan 中，这样就将数据依次传递下去了。</p>

<p>还有个细节处，<code>outputRunner</code>的Starter函数中</p>

<pre><code>if foRunner.matcher != nil {
    sampleDenom := globals.SampleDenominator
    foRunner.matcher.Start(foRunner.inChan, sampleDenom) 
} 
</code></pre>

<p>也就是，outputå自己的inChann交给对应的matcher，而router中，就是通过matcher将pack传递到outputRunner中的。</p>

<p>input的消息又是如何传到router的inChan中的呢，好好研究了一番，原来是input的数据会通过decode，传到router中，
看<code>dRunner</code>的Starter方法，有</p>

<pre><code>...
for _, p := range packs {
h.PipelineConfig().router.InChan() &lt;- p
...
</code></pre>

<p>在配置inputRunner中可能会看不到decode，实际是在inputRunner内部实现了。</p>

<p>在Encode和Decode中，使用的是指针的方式在函数间传递的，效率会比较高。</p>

<p>至于input插件的数据怎么来，output的数据怎么输出，就是插件按照自己的需求实现了。</p>

</div>
        <div class="more text-right"><a href="/2015/12/02/heka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html">继续阅读全文</a></div>
    </div>
    
    <div class="post-card">
        <div class="head"><a href="/2015/12/01/Go-Vs-Erlang.html"><span class="title">Go Vs Erlang</span></a><span class="date">2015-12-01</span></div>
        <div class="content"><ul id="markdown-toc">
  <li><a href="#section">国内的一些讨论</a></li>
  <li><a href="#section-1">国外的一些比较</a></li>
  <li><a href="#section-2">现实中的比较</a></li>
  <li><a href="#section-3">总结</a></li>
</ul>

<h2 id="section">国内的一些讨论</h2>

<p><a href="http://www.douban.com/note/233256219/" target="_blank">Erlang和Golang的几点粗浅的比较</a>、
<a href="http://blog.sina.com.cn/s/blog_6e1bd8350102uwgl.html" target="_blank">给自己一条退路，再次比较Erlang和Golang</a>、
<a href="http://studygolang.com/articles/912" target="_blank">为什么我要选择erlang+go进行服务器架构(2)</a>。</p>

<p>基本验证如下观点，语言各种各的特点，但是没有哪个语言能胜任各个场景，且比其他的都好。</p>

<ol>
  <li>Erlang 语法比较小众，入门时间会相对长一些；而从常见的语言切换到Go则比较方便  </li>
  <li>Erlang 非常适用于高并发、高稳定环境，成熟度比较高，计算密集型则表现的相对差一些；而Go在计算上更突出  </li>
  <li>Erlang成熟，但库相对少一些，Go在蓬勃发展  </li>
  <li>就像最后一个介绍的，两者也可以结合适用！  </li>
</ol>

<h2 id="section-1">国外的一些比较</h2>

<p><a href="http://joneisen.tumblr.com/post/38188396218/concurrency-models-go-vs-erlang" target="_blank">Concurrency Models: Go vs Erlang</a>; 
<a href="http://blog.erlware.org/some-thoughts-on-go-and-erlang/" target="_blank">Some Thoughts on Go and Erlang</a>。</p>

<h2 id="section-2">现实中的比较</h2>

<p>Mosquitto 开发组的成员使用Go、C、D、Erlang等语言实现了MQTT Broker的核心功能，并做了一些基本的测试，将这个语言在实际使用做了比较，<a href="https://atilanevesoncode.wordpress.com/2013/12/05/go-vs-d-vs-erlang-vs-c-in-real-life-mqtt-broker-implementation-shootout/" target="_blank">GO VS D VS ERLANG VS C IN REAL LIFE: MQTT BROKER IMPLEMENTATION SHOOTOUT</a>。</p>

<pre><code>loadtest (throughput - bigger is better)
Connections:   100            500            750            1k
D + vibe.d:    121.7 +/- 1.5  166.9 +/- 1.5  171.1 +/- 3.3  167.9 +/- 1.3
C (Mosquitto): 106.1 +/- 0.8  122.4 +/- 0.4   95.2 +/- 1.3   74.7 +/- 0.4
Erlang:        104.1 +/- 2.2  124.2 +/- 5.9  117.6 +/- 4.6  117.7 +/- 3.2
Go:             90.9 +/- 11   100.1 +/- 0.1   99.3 +/- 0.2   98.8 +/- 0.3

pingtest (latency - bigger is better)
parameters:    400p 20w       200p 200w      100p 400w
D + vibe.d:    50.9 +/- 0.3   38.3 +/- 0.2   20.1 +/- 0.1
C (Mosquitto): 65.4 +/- 4.4   45.2 +/- 0.2   20.0 +/- 0.0
Erlang:        49.1 +/- 0.8   30.9 +/- 0.3   15.6 +/- 0.1
Go:            45.2 +/- 0.2   27.5 +/- 0.1   16.0 +/- 0.1
</code></pre>

<p>文中谈到，对Go开发时使用的V1.1的版本，而测试用的是V1.2的版本，预计改善因版本问题而导致的bug后，会有10%的提升，和Erlang的新能几乎一样。</p>

<p>当然，文中隐含的提到一点，对Erlang不懂，无法评价评论。在一定程度上说明Erlang 语法确实有些小众。</p>

<h2 id="section-3">总结</h2>

<p>不要停留在语言层面了，遇到实际场景，什么合适用什么吧。</p>

</div>
        <div class="more text-right"><a href="/2015/12/01/Go-Vs-Erlang.html">继续阅读全文</a></div>
    </div>
    
    <div class="post-card">
        <div class="head"><a href="/2015/11/25/mqtt%E5%9F%BA%E7%A1%80.html"><span class="title">Mqtt基础</span></a><span class="date">2015-11-25</span></div>
        <div class="content"><ul id="markdown-toc">
  <li><a href="#mqtt">MQTT的介绍</a></li>
  <li><a href="#section">发布&amp;订阅</a></li>
  <li><a href="#clientbroker-">Client&amp;Broker 以及连接的建立</a></li>
  <li><a href="#mqttpubsub--unsub">MQTT的Pub,Sub &amp; UnSub</a></li>
  <li><a href="#topic-">Topic 及最佳实践</a></li>
  <li><a href="#qos">QOS</a></li>
  <li><a href="#persistent-session-and-queuing-messages">Persistent Session and Queuing Messages</a></li>
  <li><a href="#section-1">保留消息</a></li>
  <li><a href="#lastwill">LastWill</a></li>
  <li><a href="#section-2">保持连接和客户端接管</a></li>
  <li><a href="#section-3">总结</a></li>
</ul>

<blockquote>
  <p>今天北京风大天冷 :-)  本文是对HiveMQ上<a href="http://www.hivemq.com/blog/mqtt-essentials/" target="_blank">MQTT基础要点系列文章</a>的阅读笔记。过程中有一些疑惑地方，但是还没有及时的实践。</p>
</blockquote>

<h2 id="mqtt">MQTT的介绍</h2>

<p>轻量、开源、简单等，特点，以及历史、版本等 :-)</p>

<h2 id="section">发布&amp;订阅</h2>

<p><a href="http://www.hivemq.com/blog/mqtt-essentials-part2-publish-subscribe" target="_blank">原文</a>。</p>

<p>pub、sub的模式实现空间、实践、同步上的解耦，从而具有很好的可扩展性；对于消息，支持基于对象、内容、类型的过滤；与消息队列是不同的，后者被消费前会一直保存，且消息只能被一个客户取的，队列名称要事先创建好。</p>

<p>问题：对于后面说到的内容、类型的消息过滤，应该实际的使用体验下。</p>

<h2 id="clientbroker-">Client&amp;Broker 以及连接的建立</h2>

<p><a href="http://www.hivemq.com/blog/mqtt-essentials-part-3-client-broker-connection-establishment" target="_blank">原文</a>。</p>

<p>Client&amp;Broker的基本功能，值得一提的是，broker还要有监控订阅功能。MQTT的连接，底层是基于TCP/IP协议的，该过程中client对发送一个 <code>CONNECT</code>的消息，收到一个<code>CONNACK</code>的响应消息。</p>

<p>CONNECT Message</p>

<pre><code>contains:   Example
clientId    "client-1"
cleanSession    true 
username    "jgj"       (optional)
password    "nopassword"    (optional)
lastTopic   "/jgj/will" (optional)
lastWillQos 2       (optional)
lastWillMessage "unexpected exit" (optional)
keepAlive   60
</code></pre>

<p>clientId 用来标识客户端，所用同一个clientId被两次使用的时候，第二次的会将第一次的给覆盖。<br />
新了解的是 <code>Clean Session</code>，对应设置后续章节中的 <code>persistent session</code>。<br />
<code>lastWillXX</code>的相关信息，会在 <code>Last Will</code> 章节中有具体的说明。</p>

<p>CONNACK Message</p>

<pre><code>contains:   Example
sessionPresent  false
returnCode  0
</code></pre>

<p>不同的结果会在returnCode中表现出来。</p>

<h2 id="mqttpubsub--unsub">MQTT的Pub,Sub &amp; UnSub</h2>

<p><a href="http://www.hivemq.com/blog/mqtt-essentials-part-4-mqtt-publish-subscribe-unsubscribe" target="_blank">原文</a>。</p>

<p>PUBLISH
    packetId    4314
    topicName   “topic/1”
    qos     1
    retainFlag  false
    payload     “blabla”
    dupFlag     false</p>

<p>介绍pub/sub的一些基本过程、请求时的包，值得一提的是：Publish包中包含字段 retainFlag，在后面章节 retainedMessage专门介绍。还有个字段 packetId，当qos为0时，取值多为0，其他情况，不知道是不是会按照一定的规则生成一个。sub时，请求发送<code>SUBSCRIBE</code>信息，返回<code>SUBACK</code>信息；取消订阅 unsub时，发送<code>UNSUBSCRIBE</code>信息，返回<code>UNSUBACK</code>信息。</p>

<h2 id="topic-">Topic 及最佳实践</h2>

<p><a href="http://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-topics-best-practices" target="_blank">原文</a>。</p>

<p>Topic最好名称数字和字码，中间可以用 <code>/</code> 来分隔，开头不要是 <code>/</code>。支持统配符， <code>+</code> 只匹配单个字段，<code>#</code> 可以匹配多个，如下</p>

<pre><code>myhome/groudfloor/+/temperatur
myhome/groudfloor/liveroom/temperatur  # 匹配
myhome/liveroom/temperatur         # 不匹配
myhome/groudfloor/liveroom/fridge/temperatur  # 不匹配

myhome/groudfloor/#
myhome/groudfloor/temperature   # 匹配
myhome/groudfloor/livingroom/temperature # 匹配
myhome/firstfloor/temperatur    # 不匹配
</code></pre>

<p>按照约定，以<code>$</code>符号开头的Topic一般会认为是特殊的topic，为Broker内部统计所保留的。虽然没有明确的规定，但是参考MQTT GutHub wiki上的建议，一般会有这样的一些例子</p>

<pre><code>$SYS/broker/clients/connected
$SYS/broker/clients/disconnected
$SYS/broker/clients/total
$SYS/broker/messages/sent
$SYS/broker/uptime
</code></pre>

<p>最后对Topic的命名有一些建议，</p>

<p>. 不要以<code>/</code> 开头 <br />
. 不要用空格 <br />
. 命名简洁<br />
. Ascii字符，避免使用特殊字符<br />
. 包含clientid或唯一标识符  </p>

<h2 id="qos">QOS</h2>

<p><a href="http://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels" target="_blank">原文</a>。</p>

<p>QOS: Quality of Service。 
. 0:最多一次，请求之后就结束了<br />
. 1:最少一次，请求后存储message，等待返回消息PUBACK用于确认；若一定时间内没有收到，则再次发送<br />
. 2:只有一次，sender pub消息后，broker返回<code>PUBREC</code>；sender收到返回收再次发送<code>PUBREL</code>，broker会保留消息知道返回<code>PUBCOMP</code>   </p>

<p>qos2安全但是比较慢。</p>

<p>疑问： 如果使用QOS1或者2，publish消息后，broker收到了，但是没有订阅者，那发布者分别会有怎样的情况。</p>

<h2 id="persistent-session-and-queuing-messages">Persistent Session and Queuing Messages</h2>

<p><a href="http://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels" target="_blank">原文</a>。</p>

<p>标题应该怎么翻译呢，持续的回话和队列，大体就是这个意思了。这个是干什么用的呢，就是会有这样的一些场景，当新的订阅者连到Topic，或者是重新连接到Topic后，以前的消息还想按照顺序都得到。
如何设置呢，在前面介绍已经提到，连接的建立时通过字段 cleanSession 来设置，而且连接连接时的返回字段中也会告知是否是 persistent 的session。</p>

<p>以后用到了，在对这个地方好好说明。</p>

<h2 id="section-1">保留消息</h2>

<p><a href="http://www.hivemq.com/blog/mqtt-essentials-part-8-retained-messages" target="_blank">原文</a>。</p>

<p>应用的场景：当新的client端连接到topic时，不知道当前的状态是怎么样，如果发布者很久不发布新的状态，那新client就要一直等着或设置为不合理的默认状态。使用RetainedMessage，会保留最后的状态，新的client连接上之后，就会有最新的状态了。</p>

<p>如果设置呢？上面提到，Publish的时候，通过retainFlag字段来设置。</p>

<h2 id="lastwill">LastWill</h2>

<p><a href="http://www.hivemq.com/blog/mqtt-essentials-part-9-last-will-and-testament" target="_blank">原文</a>。</p>

<p>应用的场景：当一些连接不优雅的断掉后，其他保持连接的订阅客户端也要收到信息，从而有相应的处理。<br />
设置：在建立连接时，通过LastWillTopic、LastWillQos、LastWillMessage字段来设置，而且多和retainedMessage一起使用。 </p>

<p>注意：是pub不优雅的断掉，订阅端收到信息。而如果是优雅的断开，保存的信息会丢弃。</p>

<p>问题: LastWillTopic和Client用到的Topic是不是同一个Topic，还是所有的LastWillTopic使用同一个？</p>

<h2 id="section-2">保持连接和客户端接管</h2>

<p><a href="http://www.hivemq.com/blog/mqtt-essentials-part-10-alive-client-take-over" target="_blank">原文</a>。</p>

<p>保持连接的必要性，流程：请求 PINGREQ，返回 PINGRESP；规定时间的3/2 时间内断开。</p>

<p>如果在client端连接断开，请求重连，而broker的之前的连接还没有断开，那么broker会关闭之前的连接到现在的新连接。</p>

<h2 id="section-3">总结</h2>

<p>这系列的文章对深入一些了解mqtt的基础、用户有非常好的帮助。应该多看看原文。</p>

</div>
        <div class="more text-right"><a href="/2015/11/25/mqtt%E5%9F%BA%E7%A1%80.html">继续阅读全文</a></div>
    </div>
    
</div>

<div class="nav-post-links">
        

        
        <span class="older-posts-link">
            <a href="/page2" title="next page">Older Posts &raquo;</a>
        </span>
        
</div>

                    </div>
                    <div class="col-md-3" id="main-right">
                        <div>
    <h4><strong>文章分类</strong></h4>
    <hr class="small-margin colored-hr" />
    <ul class="side-cat-ul">
        
        <li><a href="/categories.html#cat-生活随记" title="生活随记">生活随记 (3)</a></li>
        
        <li><a href="/categories.html#cat-bigdata" title="bigdata">bigdata (9)</a></li>
        
        <li><a href="/categories.html#cat-web" title="web">web (9)</a></li>
        
        <li><a href="/categories.html#cat-database" title="database">database (3)</a></li>
        
        <li><a href="/categories.html#cat-linux" title="linux">linux (10)</a></li>
        
        <li><a href="/categories.html#cat-go" title="go">go (8)</a></li>
        
        <li><a href="/categories.html#cat-运维" title="运维">运维 (3)</a></li>
        
        <li><a href="/categories.html#cat-language" title="language">language (7)</a></li>
        
        <li><a href="/categories.html#cat-tools" title="tools">tools (1)</a></li>
        
        <li><a href="/categories.html#cat-iot" title="iot">iot (5)</a></li>
        
    </ul>
</div>

<hr class="small-margin colored-hr" />

<!-- google adsense -->
<!--
<div>
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <ins class="adsbygoogle"
        style="display:inline-block;width:300px;height:600px"
        data-ad-client="ca-pub-1339945837472110"
        data-ad-slot="8220828081"></ins>
    <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
</div>
-->


                    </div>
                </div>
            </div>

            <div id="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <hr class="colored-hr" />

                <p class="text-center">
                Copyright 2014 - 2016 | Gen time&#58; 2016-04-12 01:51:47 CST

                <!-- cnzz -->
                

                </p>


            </div>
        </div>
    </div>
    <div style="display:none;" class="back-to" id="toolBackTop">
        <a title="返回顶部" onclick="window.scrollTo(0,0);return false;" href="#top" class="back-top">返回顶部</a>
    </div>

    <!-- google analytics -->
    


</div>

    </body>
</html>
