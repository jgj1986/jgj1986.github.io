<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="author" content="jgj" />
        <meta name="viewport" content="width=device-width" /> 
        <title>记录生活工作中的点滴 | 我是疯子</title>
        

        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- bootstrap source -->
        <!-- 新 Bootstrap 核心 CSS 文件 -->
        <link rel="stylesheet" href="http://cdn.bootcss.com/bootstrap/3.2.0/css/bootstrap.min.css" />
        <!-- 可选的Bootstrap主题文件（一般不用引入） -->
        <link rel="stylesheet" href="http://cdn.bootcss.com/bootstrap/3.2.0/css/bootstrap-theme.min.css" />
        <!-- jQuery文件。务必在bootstrap.min.js 之前引入 -->
        <script src="http://cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>
        <!-- 最新的 Bootstrap 核心 JavaScript 文件 -->
        <script src="http://cdn.bootcss.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>

        <link rel="stylesheet" href="/asset/css/kissdata.css" />

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
            <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <link href="/feed.html" rel="alternate" title="jgj" type="application/atom+xml" />
        <link rel="shortcut icon" href="/favicon.ico" />
        <link rel="icon" href="/favicon.ico" />

        <style type="text/css">
            body {
                padding-top: 55px;
                padding-bottom: 30px;
                background-color: #EEE;
            }
        </style>

        <link rel="stylesheet" href="/asset/js/google-code-prettify/prettify.css">
        <script src="/asset/js/google-code-prettify/prettify.js"></script>

        <script type="text/javascript">
            $(document).ready(function () {

                // go to top
                var bt = $('#toolBackTop'); var sw = $(document.body)[0].clientWidth; var limitsw = (sw - 840) / 2 - 80; if (limitsw > 0){ limitsw = parseInt(limitsw); bt.css("right",limitsw); } $(window).scroll(function() { var st = $(window).scrollTop(); if(st > 30){ bt.show(); }else{ bt.hide(); } });

                // google-code-prettify
                $("pre").addClass("prettyprint linenums"); prettyPrint();

            })
        </script>

        <!-- kp747 
        
        -->
    </head>
    <body>
            <div id="header">
    <!-- Fixed navbar -->
    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand normal-a" href="javascript:void(0)" onclick="javascript:void(0)">
                    <span id="site_name">我是疯子</span>
                </a>
            </div>

            <div id="navbar" class="navbar-collapse collapse">
                <ul class="nav navbar-nav">
                    <li><a href="/">首页</a></li>
                    <li><a href="/categories.html">分类</a></li>
                    <li><a href="/guestbook.html">留言</a></li>
                    <li><a href="/about.html">关于</a></li>
                    <li><a href="/feed.html">RSS</a></li>
                    <li><a href="javascript:void(0)" class="normal-a" onclick="javascript:void(0)"><span id="site_description">在此停留片刻，偶有所得！</span></a></li>
                </ul>
            </div><!--/.nav-collapse -->
        </div>
    </nav>
</div>


            <div class="container">
                <div class="row">
                    <div class="col-md-9" id="main-left">
                        <h1>记录生活工作中的点滴</h1>

<hr class="small-margin" />

<div>
    
    <div class="post-card">
        <div class="head"><a href="/2015/11/04/C++basic.html"><span class="title">C++basic</span></a><span class="date">2015-11-04</span></div>
        <div class="content"><h2 id="creatediries">creatediries</h2>
<p>使用boost::filesystem 创建目录的代码：</p>

<pre><code>#include "boost/filesystem.hpp"
#include &lt;iostream&gt;
int main() {
    boost::filesystem::path dir("/tmp/test");
boost::system::error_code ec;
try {
        if (boost::filesystem::create_directories(dir, ec))
        std::cout &lt;&lt; "success create" &lt;&lt; std::endl;
    } catch (...) {
        std::cout &lt;&lt; "Unexpedted exception. [error='" &lt;&lt;  ec.message().c_str() &lt;&lt; "']";
}
return 0;
}
</code></pre>

<p>而如果将路径换成 “/tmp/test/” 的时候，create_direcotries的执行结果为false，但是ec的信息还是”Success”，这就 ^_^ …</p>

<h2 id="c11-">C++11 的一些特性</h2>
<p><a href="http://blog.csdn.net/augusdi/article/details/11773163" target="_blank">C++11新特性</a>。C++11标准引入了一些新特性，这最近的使用中就遇到了一次。</p>

<pre><code>#define VALIDATE_PARAMS(index, name, vars, type, def_value) \
do { \ 
    vars = m_conf_root[catalog].get(name, def_value).as##type(); \
    if (def_value == vars) { \
PUSHER_LOG_WARNING("Params isn't defined. [param='%s']", "["index"]"name); \
    return ERROR; \
    } \
} while(0)
                                                                      
VALIDATE_PARAMS("coco", "import_things", m_output_path, String, "_");
</code></pre>

<p>编译的时候会有错误提示：</p>

<pre><code>error: inconsistent user-defined literal suffixes ‘index’ and ‘name’ in string literal
error: unable to find string literal operator ‘operator"" index’
</code></pre>

<p>因为C++11中对用户自定义的语法强制要求要有空格。所以上面的一行必须如下定义：</p>

<pre><code>PUSHER_LOG_WARNING("Params isn't defined. [param='%s']", "[" index"]" name); \
</code></pre>

<h2 id="section">小知识点</h2>

<p>判断字符串是否以 ‘xxx’ 结尾</p>

<pre><code>#define ENDSWITH(str, suffix)   \                         
((str).rfind(suffix) == (str).size() - strlen(suffix))
</code></pre>

<p>find返回suffix在str的索引，rfind则是从后向前查找。</p>

</div>
        <div class="more text-right"><a href="/2015/11/04/C++basic.html">继续阅读全文</a></div>
    </div>
    
    <div class="post-card">
        <div class="head"><a href="/2015/07/17/Linux%E4%BD%BF%E7%94%A8studio%E8%81%94%E8%B0%83android%E8%AE%BE%E5%A4%87.html"><span class="title">Linux使用studio联调android设备</span></a><span class="date">2015-07-17</span></div>
        <div class="content"><ul id="markdown-toc">
  <li><a href="#section">手机设置</a></li>
  <li><a href="#linux">Linux识别设备</a></li>
  <li><a href="#section-1">展示</a></li>
</ul>

<blockquote>
  <p>Windows 下IDE连接android设备做联调好像很容易；其实如果在Linux下能完成这个过程，发现其实也不是件很困难的事情。</p>
</blockquote>

<h2 id="section">手机设置</h2>
<p>手机要处于USB可调试状态。不同手机上的设置不一样，此处不赘述。</p>

<h2 id="linux">Linux识别设备</h2>

<p>usb线连接移动设备和Linux电脑后，确保如下命令能看到设备</p>

<pre><code>$ adb devices
List of devices attached 
50536cf1    device
</code></pre>

<p>关于adb的安装，此处不介绍。本人使用的ubuntu系统，所需要的udev驱动等，系统默认的应该都已经有了。
而在识别设备时，遇到了一些问题，参看博客 <a href="http://blog.csdn.net/liuqz2009/article/details/7942569" target="_blank">在Linux下adb连接不上android手机的终极解决方案</a>。</p>

<p>我在操作过程中，修改了博客中说到的两个地方</p>

<pre><code>$ lsusb
Bus 001 Device 009: ID 2717:0368   # 安卓设备
... 
$ cat /etc/udev/rules.d/51-android.rules
SUBSYSTEMS=="usb", ATTRS{idVendor=="2717", ATTRS{idProduct}=="0368", MODE="0666", OWNER="jgj"} 
$ cat ~/.android/adb_usb.ini
0x2717
</code></pre>

<p>重新启动adb server</p>

<h2 id="section-1">展示</h2>

<p>在Android Studio 中选择一个项目，下面选择 “android”，然后选择连接的设备。
这个时候输出的日志会非常多，可以在做过滤。</p>

</div>
        <div class="more text-right"><a href="/2015/07/17/Linux%E4%BD%BF%E7%94%A8studio%E8%81%94%E8%B0%83android%E8%AE%BE%E5%A4%87.html">继续阅读全文</a></div>
    </div>
    
    <div class="post-card">
        <div class="head"><a href="/2015/07/07/libevent_learn.html"><span class="title">Libevent_learn</span></a><span class="date">2015-07-07</span></div>
        <div class="content"><ul id="markdown-toc">
  <li><a href="#section">事件处理机制</a></li>
  <li><a href="#section-1">简单例子</a></li>
  <li><a href="#section-2">连接监听器</a></li>
</ul>

<blockquote>
  <p>最近接收的项目中用到了libevent的机制，为了更好的理解项目，也就学习了一下libevent。</p>
</blockquote>

<h2 id="section">事件处理机制</h2>

<p><a href="blog.csdn.net/sparkliang/article/category/660506" target="_blank">libevent源码深度剖析</a>系列文章好好读一遍，简单的记录比较有启发的一些知识点。</p>

<p>应用程序需要提供相应的接口并注册到Reactor上，作为“回调函数”。<br />
其执行顺序:<br />
* 初始化libevent库、初始化事件event<br />
* 设置event从属的event_base<br />
* 添加事件<br />
* 进入无限循环 event_base_dispatch(base);</p>

<h2 id="section-1">简单例子</h2>

<p>参考 <a href="http://blog.csdn.net/yyyiran/article/details/12219737" target="_blank">libevent简介和使用</a>中简单入门的例子，</p>

<pre><code>#include &lt;stdio.h&gt;  
#include &lt;iostream&gt;   
#include &lt;event.h&gt;   
  
// 定时事件回调函数  
void onTime(int sock, short event, void *arg) {  
    cout &lt;&lt; "sub process!" &lt;&lt; endl;      
    struct timeval tv;  
    tv.tv_sec = 1;  
    tv.tv_usec = 0;  
    // 重新添加定时事件（定时事件触发后默认自动删除）  
    event_add((struct event*)arg, &amp;tv);  
}  
  
int main() {  
    // 初始化  
    event_init();  
  
    struct event evTime;  
    // 设置定时事件  
    evtimer_set(&amp;evTime, onTime, &amp;evTime);  
  
    struct timeval tv;  
    tv.tv_sec = 1;  
    tv.tv_usec = 0;  
    // 添加定时事件  
    event_add(&amp;evTime, &amp;tv);  
   
    event_dispatch();     
    return 0;  
}  
</code></pre>

<p>实际过程中更常用的方式是：</p>

<pre><code>base = event_base_new();     
event_base_set(base, &amp;evListen);  
// 添加事件  
event_add(&amp;evListen, NULL);        
// 事件循环  
event_base_dispatch(base);
</code></pre>

<h2 id="section-2">连接监听器</h2>
<p>系统这样设计的：有多个进程(10)个，对外提供接口服务，一个进程做监控，当服务的某个进程挂掉后，监控进程会将对应(端口)的服务在启动起来。
在线上服务运行时遇到这样一个现象，每个服务进程在执行完成之后，都就没有了，监控进程又重新启动起来了。<br />
因为使用了libevent中的 <code>evconnlistener_new_bind</code> 来创建这样的服务，好好研究下怎么使用。
最后发现，在服务代码中两次释放一个内存地址，导致core dump。但是在这个过程中还是好好的了解了一下连接监听器的使用。</p>

<p>博客<a href="http://blog.csdn.net/luotuo44/article/details/38800363" target="_blank">Libevent源码分析—–连接监听器evconnlistener</a><br />
从如何使用到代码的实现等方面对此作了比较详细的介绍，这里只简单的列出一些自己觉得如果比较有用的代码。</p>

<pre><code>event_base *base = event_base_new();  
evconnlistener *listener  
        = evconnlistener_new_bind(base, listener_cb, base,  
            LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE | LEV_OPT_THREADSAFE,  
            10, (struct sockaddr*)&amp;sin,  
            sizeof(struct sockaddr_in));  
  
event_base_dispatch(base);  
evconnlistener_free(listener);  
event_base_free(base);
</code></pre>

<p>创建好连接之后，使用 <code>event_base_dispatch</code> 进入到了循环等待。 <code>listener_cb</code>可以如下的形式实现：</p>

<pre><code>void listener_cb(evconnlistener *listener, evutil_socket_t fd,
    struct sockaddr *sock, int socklen, void *arg) {
    event_base *base = (event_base*)arg;
    bufferevent *bev =  bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);    
    
bufferevent_setcb(bev, socket_read_cb, NULL, socket_error_cb, NULL);
    bufferevent_enable(bev, EV_READ | EV_PERSIST);
}
</code></pre>

</div>
        <div class="more text-right"><a href="/2015/07/07/libevent_learn.html">继续阅读全文</a></div>
    </div>
    
    <div class="post-card">
        <div class="head"><a href="/2015/06/09/C++%E4%BB%A3%E7%A0%81%E7%AC%94%E8%AE%B0.html"><span class="title">C++代码笔记</span></a><span class="date">2015-06-09</span></div>
        <div class="content"><ul id="markdown-toc">
  <li><a href="#epoll">epoll</a></li>
  <li><a href="#callback">callback函数</a></li>
</ul>

<blockquote>
  <p>摩羯存储中有很多技巧性很高的代码，此处只是一些笔记。</p>
</blockquote>

<h2 id="epoll">epoll</h2>
<p>epoll和select的区别网上讨论的很多，计划后续再整理篇博客，加上与libevent的比较。<br />
唠叨两句epoll的知识点，主要是三个函数：</p>

<pre><code>int epoll_create(int size);
int epoll_ctl(int epfd, intop, int fd, struct epoll_event *event);
int epoll_wait(int epfd,struct epoll_event * events,int maxevents,int timeout);
</code></pre>

<p>而在代码中使用了ae_epoll.c，可以参考<a href="http://www.cnblogs.com/liuhao/archive/2012/05/16/2505491.html" target="_blank">redis中ae_epoll.c的源代码</a>，对aeEventLoop做了调整：</p>

<pre><code>typedef struct {
    Conn* conns[AE_SIZE];
    int fired[AE_SIZE];
    int nready;
    void *apidata;
} aeEventLoop;
</code></pre>

<p>定义使用函数，并且影响使用方法</p>

<pre><code>public：

    aeEventLoop *loop() {
        return &amp;m_loop;
    }
    ...
Private:
    aeEventLoop m_loop;

    ...
server-&gt;loop()-&gt;conns[fd] = c;
</code></pre>

<p>在初始化是，结构体成员conns中每个元素的下标为连接的文件描述符，元素则为连接，如:</p>

<pre><code>Conn* c = conn_new(fd, ...);
server-&gt;loop()-&gt;conns[fd] = c;
</code></pre>

<p>在epoll_wait得到的连接的文件描述符，从而可以得到连接的conn。</p>

<pre><code>eventLoop-&gt;fired[j].fd = e-&gt;data.fd;
int fd = server-&gt;loop()-&gt;fired[j];
Conn *c = server-&gt;loop()-&gt;conns[fd];
</code></pre>

<p>当有数据到来时，借用epoll的实现机制，callback的方式处理。</p>

<pre><code>callback = server-&gt;conf().callback();
if (callback) {
    Status status = callback(c);
...
</code></pre>

<p>处理完这儿接收的数据格式之后，可能还有别的数据(如不符合规范的数据)，对于这样的数据，再次获取后处理。</p>

<h2 id="callback">callback函数</h2>

<p>此处想达到这样一个目的，根据接收到命令的不同由不同的函数处理，而不希望采用类似 <code>switch</code>的语句来实现。这里就有段比较精妙的代码：</p>

<pre><code>// 定义处
// in class
typedef int(Executor::*cmd_handler_t)(const Request&amp; req, Response* res);
struct command_t {                          
    std::strin      key;      
    handler_t       _handler; 
};
typedef std::map&lt;std::string, command_t&gt; command_map_t;
const Executor::command_map_t Executor::s_commands = set_commands();
  
Executor::command_map_t Executor::set_commands() {
    command_map_t commands;
    command_t set = {"SET0", &amp;Executor::_set_value};
    command_t get = {"GET0", &amp;Executor::_get_value};

    commands.insert(std::make_pair("SET", set));
    commands.insert(std::make_pair("GET", get));
    return commands;
}

int Executor::_set_value(const char* cmd, Request* request) {
    //...
}
int Executor::_get_value(const char* cmd, Request* request) {
    // ... 
}
int Executor::dispatch(Conn *c, const char* cmd, Request* request) {
    command_map_t::const_iterator cmd_it = s_commands.find(cmd);
    // if it not end
    int res = (Executor::_instance()-&gt;*cmd_it-&gt;second._handler)(cmd, response);
    // others
}

// 函数实现过程
int callback(Conn *c) {
    //... read data from socket to buf
    Executor* executor = Executor::_instance();
    int res = executor-&gt;dispatch(c, buf, &amp;request);
    //... back ret_data
    return res;
}

// 调用处
// CLASS
typedef int (*callback_func)(Conn *c);
void Caller::set_callback(const callback_func&amp; callback) {
    m_callback = callback;
}
//在类初始化时通过该方法设置
// 调用  参考上一节最后代码段 
</code></pre>

</div>
        <div class="more text-right"><a href="/2015/06/09/C++%E4%BB%A3%E7%A0%81%E7%AC%94%E8%AE%B0.html">继续阅读全文</a></div>
    </div>
    
    <div class="post-card">
        <div class="head"><a href="/2015/06/04/python_learn.html"><span class="title">Python_learn</span></a><span class="date">2015-06-04</span></div>
        <div class="content"><ul id="markdown-toc">
  <li><a href="#python">python字符串操作</a></li>
  <li><a href="#python-1">python简洁的表达式：</a></li>
  <li><a href="#section">特殊语法</a>    <ul>
      <li><a href="#filterfunction-sequence">filter(function, sequence)</a></li>
      <li><a href="#mapfunction-sequence">map(function, sequence)</a></li>
      <li><a href="#reducefunction-sequence-startingvalue">reduce(function, sequence, starting_value)</a></li>
      <li><a href="#lambda">lambda</a></li>
      <li><a href="#for">for特殊用法</a></li>
      <li><a href="#zip">zip</a></li>
    </ul>
  </li>
  <li><a href="#section-1">一个例子</a></li>
</ul>

<h2 id="python">python字符串操作</h2>
<p><a href="http://blog.chinaunix.net/uid-25992400-id-3283846.html" target="_blank">python字符串操作和string模块代码分析</a></p>

<pre><code>str.zfill(20)       #str右对齐，左边填充0
</code></pre>

<p>set判断元素是否存在 </p>

<pre><code>if key in set:
    xxx
</code></pre>

<p>json解析后变为dict，判断是否有</p>

<pre><code>if dict.has_key(key)：
    xxxx
</code></pre>

<h2 id="python-1">python简洁的表达式：</h2>

<pre><code>print [x for x in foo if x % 3 == 0]
</code></pre>

<p>python 中lambda用来创建匿名函数，参考<a href="http://blog.csdn.net/imzoer/article/details/8667176" target="_blank">Python中lambda表达式</a>:</p>

<pre><code>fs = [(lambda n, i=i : i + n) for i in range(10)]   
</code></pre>

<p>call:</p>

<pre><code>fs[1](3)
4
fs[4](3)
7
</code></pre>

<p>n的阶乘</p>

<pre><code>n = 5
reduce(lambd x,y:x*y,range(1, n+1))
</code></pre>

<p>lambda用户函数表达式</p>

<pre><code>def action(x)
return lambda y:x+y

a = action(2)
a(22)
#24

b = lambda x:lambda y:x+y
a = b(2)
a(22)
#24
</code></pre>

<h2 id="section">特殊语法</h2>

<p>转载一篇博客 <a href="http://www.cnblogs.com/linjiqin/p/4222160.html" target="_blank">Python特殊语法–filter、map、reduce、lambda</a></p>

<h3 id="filterfunction-sequence">filter(function, sequence)</h3>

<p>对sequence中的item依次执行function(item)，将执行结果为True的item组成一个List/String/Tuple(取决于sequence的类型)返回：</p>

<pre><code>def f(x): 
return x % 2 != 0 and x % 3 != 0 

print filter(f, range(2, 25)) 
#[5, 7, 11, 13, 17, 19, 23]

def f1(x): 
return x != 'a' 

print filter(f1, "abcdef") 
#bcdef 
</code></pre>

<h3 id="mapfunction-sequence">map(function, sequence)</h3>

<p>对sequence中的item依次执行function(item)，见执行结果组成一个List返回：</p>

<pre><code>def cube(x): 
return x*x*x 
print map(cube, range(1, 11)) 
#[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]

def cube1(x): 
return x + x 
print map(cube1 , "abcde") 
#['aa', 'bb', 'cc', 'dd', 'ee']
</code></pre>

<p>另外map也支持多个sequence，这就要求function也支持相应数量的参数输入：</p>

<pre><code>def add(x, y): 
return x+y 
print map(add, range(8), range(8)) 
#[0, 2, 4, 6, 8, 10, 12, 14]

status_ids = map(lambda x:x.get('status__id'), snaps)
</code></pre>

<h3 id="reducefunction-sequence-startingvalue">reduce(function, sequence, starting_value)</h3>

<p>对sequence中的item顺序迭代调用function，如果有starting_value，还可以作为初始值调用，例如可以用来对List求和：</p>

<pre><code>def add(x,y):
return x + y 
print reduce(add, range(1, 11)) 
注：1+2+3+4+5+6+7+8+9+10

reduce(add, range(1, 11), 20) 
注：1+2+3+4+5+6+7+8+9+10+20
</code></pre>

<h3 id="lambda">lambda</h3>

<p>这是Python支持一种有趣的语法，它允许你快速定义单行的最小函数，类似与C语言中的宏，这些叫做lambda的函数，是从LISP借用来的，可以用在任何需要函数的地方： </p>

<pre><code>g = lambda x: x * 2 
print g(3) 
#6 

print (lambda x: x * 2)(3) 
#6
</code></pre>

<h3 id="for">for特殊用法</h3>
<pre><code>for i in range(4):
print i

se=[x**2 for x in range(4)]
print se 
#[0, 1, 4, 9]

se=[x**2 for x in range(10) if not x%2]
print se 
#[0, 4, 16, 36, 64]
</code></pre>

<h3 id="zip">zip</h3>
<p>zip函数接受任意多个（包括0个和1个）序列作为参数，返回一个tuple列表。</p>

<pre><code>x = [1, 2, 3]
y = [a, b, c]
z = [A, B, C]
xyz = zip(x, y, z)
print xyz   
#[(1,a,A),(2,b,B),(3,c,C)]
</code></pre>

<h2 id="section-1">一个例子</h2>

<pre><code>test=[[['db','table','index'],'key','val'], [['db1','table1','index1'],'key1','val1']]
tables = [reduce(lambda a,b: a+b,[(y if type(y) == type([]) else [y]) for y in x ]) for x in test ]
#[['db', 'table', 'index', 'key', 'val'], ['db1', 'table1', 'index1', 'key1', 'val1']]
</code></pre>

</div>
        <div class="more text-right"><a href="/2015/06/04/python_learn.html">继续阅读全文</a></div>
    </div>
    
    <div class="post-card">
        <div class="head"><a href="/2015/06/03/spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><span class="title">Spark学习笔记</span></a><span class="date">2015-06-03</span></div>
        <div class="content"><ul id="markdown-toc">
  <li><a href="#section">配置</a></li>
  <li><a href="#sparksqljson">sparksql操作json文件</a></li>
  <li><a href="#section-1">结果存放</a></li>
  <li><a href="#section-2">提交任务</a></li>
</ul>

<h3 id="section">配置</h3>

<p><a href="http://spark.apache.org/docs/latest/index.html" target="_blank">spark 1.3的官网</a>上介绍了spark集群的几种方式：
Amazon EC2<br />
Standalone Deploy mode<br />
Apache Mesos<br />
Hadoop YARN<br />
因为平时都在使用hadoop，在测试时为了更好的了解安装部署的情况，就使用yarn的方式。</p>

<p>spark有两种运行的方式，一种是提交任务到master，spark管理任务的执行(使用命令spark-submit)；还有一种就是在客户端交互的方式运行，使用命令(spark-sell或pyspark，其中pyspark是python专用的)</p>

<p>关于spark的配置，可以在启动时通过命令的方式传递，如</p>

<pre><code>./bin/spark-submit --name "My app" --master local[4] --conf spark.shuffle.spill=false     --conf "spark.executor.extraJavaOptions=-XX:+PrintGCDetails -XX:+PrintGCTimeStamps" myApp.jar
</code></pre>

<p>如果没有这种动态的配置，spark会使用 conf/spark-defaults.conf配置文件中的内容<br />
配置情况如：</p>

<pre><code>spark.master                     spark://172.16.101.13:7077
spark.eventLog.enabled           true
spark.eventLog.dir               hdfs://hadoop-master:9000/tmp/spark_events
spark.serializer                 org.apache.spark.serializer.KryoSerializer
spark.driver.memory              1g
spark.executor.extraJavaOptions  -XX:+PrintGCDetails -Dkey=value
</code></pre>

<p>网上有关于该文件的说明，这里只是说明 spark.eventLog.dir配置，后面的域名和hadoop的core-site.xml中的<code>fs.default.name</code>的value一致。<br />
有了该配置文件后，直接启动 pyspark 时，在最后会有输出：</p>

<pre><code>SparkContext available as sc, HiveContext available as sqlCtx
</code></pre>

<p>这种情况下，我们使用使用变量<code>sc</code>就可以了。本人在测试时，如果再次试图初始化(sc=SparkContext())会报错 <code>ValueError: Cannot run multiple SparkContexts at once</code></p>

<h3 id="sparksqljson">sparksql操作json文件</h3>

<p>spark使用DATAFrame，其来源可以是存在的rdd、hive表、数据源。最简单而轻言，json格式的文件就可以直接使用。总的来看，支持的比较好. 
参考<a href="http://spark.apache.org/docs/latest/sql-programming-guide.html" target="_blank">Spark SQL and DataFrame Guide</a>和<a href="http://www.cstor.cn/textdetail_8471.html" target="_blank">http://www.cstor.cn/textdetail_8471.html</a>。<br />
假设我有push上传的json格式日志，每一行都如下：</p>

<pre><code>{"event_id":1,"body":{"brand":"samsung","imsi":"454197000461112","dvid":"45yuifghjmd","cc":"HK","osv":"5.0","dtn":"SM-N9005","sr":"1920,1080","mac":"48:5A:3F:23:09:E1","platform":"android","net":"wifi"}}
</code></pre>

<p>该日志文件已经存放在hdfs的/mjyun/txt/push_json.log。</p>

<pre><code>pyspark
&gt;&gt;&gt; from pyspark.sql import SQLContext
&gt;&gt;&gt; sqlContext = SQLContext(sc)
&gt;&gt;&gt; df = sqlContext.jsonFile("/mjyun/txt/push_json.log")
&gt;&gt;&gt; df.select("event_id").show()
&gt;&gt;&gt; df.select("body.brand").show()  #json嵌套
</code></pre>

<p>求活跃设备数，即对dvid的去重数。</p>

<pre><code>pyspark
&gt;&gt;&gt; from pyspark.sql import SQLContext
&gt;&gt;&gt; sqlContext = SQLContext(sc)
&gt;&gt;&gt; event = sqlContext.jsonFile("/mjyun/txt/push_json.log")
&gt;&gt;&gt; event.registerTempTable("event")
&gt;&gt;&gt; cnt = sqlContext.sql("select count(distinct body.dvid) from event")
&gt;&gt;&gt; for value in cnt.collect():
...     print value
...
    Row(c0=964)
</code></pre>

<p>如果包含多个文件呢？在引入文件的时候，使用逗号隔开，直接包含多个文件即可，如下：</p>

<pre><code>&gt;&gt;&gt;  df = sqlContext.jsonFile("/mjyun/txt/push_json.log,/mjyun/txt/push2.json")
</code></pre>

<h3 id="section-1">结果存放</h3>

<p>假设要计算新增设备数，则需要将以前出现过的设备都做存储，然后将本次的设备和之前出现的设备做比较。这里的第一步就需要先保存结果！
如上面的文件加载到了内存后</p>

<pre><code>&gt;&gt;&gt; df.select("body.dvid","body.net").save("/mjyun/mid/devNet.parquet") 
或者(支持 json, parquet, jdbc)
&gt;&gt;&gt; df.select("body.dvid","body.net").save("/mjyun/mid/devNet.json","json")
重新加载
&gt;&gt;&gt; newdf = sqlContext.load("/mjyun/mid/devNet.json","json")
</code></pre>

<p>无锁非原子性，所以可能就会有错误。而在存储的时候，为了有更好的性能，采用分区方式存放(类似于hive分区)。<br />
例如在我们的应用的可以是 /mjyun/txt/appid=1222/ym=201506/day=02/<br />
支持数据的合并  </p>

<h3 id="section-2">提交任务</h3>

<pre><code>$ cat new_dev.py 
from pyspark import SQLContext, SparkContext, SparkConf
conf = SparkConf().setAppName("testNewDevCnt").setMaster("spark://172.16.101.13:7077")
sc = SparkContext(conf=conf)
sqlContext = SQLContext(sc)

df = sqlContext.jsonFile("/mjyun/txt/push2.json")
df.select("body.ckid").save("appDevVer.parquet")
sc.stop()

$ spark-submit ./new_dev.py 
</code></pre>

</div>
        <div class="more text-right"><a href="/2015/06/03/spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html">继续阅读全文</a></div>
    </div>
    
    <div class="post-card">
        <div class="head"><a href="/2015/05/05/ngx_lua%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81%E5%BA%93.html"><span class="title">Ngx_lua使用代码库</span></a><span class="date">2015-05-05</span></div>
        <div class="content"><ul id="markdown-toc">
  <li><a href="#luac">lua调用C函数</a></li>
  <li><a href="#section">基础函数</a>    <ul>
      <li><a href="#section-1">初始化函数</a></li>
      <li><a href="#section-2">库函数</a></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>使用ngx_lua重构服务端接口时，用到加密、解密算法，原来使用C来实现，有很多的位操作，使用lua来重构会比较麻烦，不如直接用使用C库形式。在开发过程中，有一些基础的函数，会在多个地方调用，通过库的形式调用，会更加优雅一些。</p>
</blockquote>

<h2 id="luac">lua调用C函数</h2>
<p>参考 <a href="http://www.cnblogs.com/stephen-liu74/archive/2012/07/23/2469902.html" target="_blank">Step By Step(Lua调用C函数)</a>，此处只是做简单说明。</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;lua.hpp&gt;
#include &lt;lauxlib.h&gt;
#include &lt;lualib.h&gt;
static int add(lua_State* L) {  // 以栈的形式传递参数
    double op1 = luaL_checknumber(L,1);  // 1表示Lua调用时的第一个参数(从左到右)，依此类推
    double op2 = luaL_checknumber(L,2); 
    lua_pushnumber(L,op1 + op2); // 将函数的结果压入栈中。如果有多个返回值，可以在这里多次压入栈中
    return 1;
}
static luaL_Reg testLibName[] = { // luaL_Reg结构体的第一个字段为字符串，在注册时用于通知Lua该函数的名字
{"add", add},
{NULL, NULL} // 结构体数组中的最后一个元素的两个字段均为NULL，用于提示Lua注册函数已经到达数组的末尾
};
// 其函数名必须为luaopen_xxx，其中xxx表示library名称。Lua代码require "xxx"需要与之对应
int luaopen_testLibName(lua_State* L){ 
const char* libName = "testLibName";
luaL_register(L,libName,testLibName);  // 需要强调的是，所有需要用到"xxx"的代码，不论C还是Lua，都必须保持一致，这是Lua的约定
return 1;
}
</code></pre>

<p>为了方便，通过Makefile文件执行编译：</p>

<pre><code>##### Build defaults #####
LUA_VERSION =       5.1
TARGET =            test.so
PREFIX =            /usr/local/luajit
CFLAGS =            -O3 -Wall -pedantic -DNDEBUG
CJSON_CFLAGS =      -fpic
CJSON_LDFLAGS =     -shared
LUA_INCLUDE_DIR =   $(PREFIX)/include/luajit-2.0
LUA_CMODULE_DIR =   $(PREFIX)/lib/lua/$(LUA_VERSION)
LUA_MODULE_DIR =    $(PREFIX)/share/lua/$(LUA_VERSION)
LUA_BIN_DIR =       $(PREFIX)/bin

BUILD_CFLAGS =      -I$(LUA_INCLUDE_DIR) $(CJSON_CFLAGS)
OBJS =               test.o

.PHONY: all clean
.c.o:
$(CC) -c $(CFLAGS) $(CPPFLAGS) $(BUILD_CFLAGS) -o $@ $&lt;
all: $(TARGET)

$(TARGET): $(OBJS)
$(CC) $(LDFLAGS) $(CJSON_LDFLAGS) -o $@ $(OBJS)
clean:
rm -f *.o $(TARGET)
</code></pre>

<p>在ngx_lua中使用，将生成的 test.so 放在特定的目录下，nginx.conf 以类似 <code>lua_package_cpath '/usr/local/nginx_lua/lua_so/?.so;;';</code> 的形式包含，
参考<a href="http://blog.kissdata.com/2014/11/14/nginx-lua-install.html" target="_blank">nginx与lua的安装教程</a>。<br />
上面使用 <code>lua_pushnumber</code>函数，在实际的过程中，使用的可能是 <code>lua_pushlstring</code>，更多的函数，
可以查阅 <a href="http://www.codingnow.com/2000/download/lua_manual.html" target="_blank">lua 参考手册</a></p>

<h2 id="section">基础函数</h2>
<p>实际编码过程中，会有一些逻辑，在多个地方被调用。采用基础函数的方式来实现，是比较好的选择。而其实现，也有几种方式</p>

<h3 id="section-1">初始化函数</h3>
<p>nginx.conf 的 http 模块中，通过 <code>init_by_lua_file /path/init.lua;</code> 的方式配置初始化文件，在nginx启动时，
会将文件中的内容(变量、函数、共享内存)等加载到内存，在整个nginx运行过程中均可以被使用。文件中内容为全局的，可直接使用变量、函数。<br />
但是init文件只能有一个，如果太多的东西都塞进来，文件会比较冗长，阅读不方便，且一致占用内存</p>

<h3 id="section-2">库函数</h3>
<p>通过<code>lua_package_path '/path1_to/lua_so/?.lua;/path2_to/?.lua;';</code> 的方式指定路径。有 com.lua 文件如下</p>

<pre><code>local null = ngx.null
local unpack = unpack
local setmetatable = setmetatable

local _M = { _VERSION = '0.1' }
local mt = { __index = _M }

function _M.new(self)
math.randomseed(os.time())
return setmetatable({}, mt)
end

function _M.genReturnTable(self,a)
local obj = {}
obj.dtl = "ok"
obj.str = a
return obj
end
function _M.testFun(self, a)
    -- check a !
    -- when call inner function, user _M.xx(self, ...)
    return _M.genReturnTable(self, a)
end

return _M
</code></pre>

<p>在使用调用内容，则如下</p>

<pre><code>local com = require("com")
com.testFun("testStr")
</code></pre>

<p>注意，对于lua类方法的调用，则要用<code>:</code>    </p>

</div>
        <div class="more text-right"><a href="/2015/05/05/ngx_lua%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81%E5%BA%93.html">继续阅读全文</a></div>
    </div>
    
    <div class="post-card">
        <div class="head"><a href="/2015/04/07/%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2.html"><span class="title">数据格式转换</span></a><span class="date">2015-04-07</span></div>
        <div class="content"><ul id="markdown-toc">
  <li><a href="#section">数字转字符串</a>    <ul>
      <li><a href="#c">C++</a></li>
      <li><a href="#python">python</a></li>
      <li><a href="#go">go</a></li>
      <li><a href="#shell">shell</a></li>
    </ul>
  </li>
  <li><a href="#section-1">字符串转数字</a>    <ul>
      <li><a href="#c-1">C++</a></li>
      <li><a href="#go-1">go</a></li>
      <li><a href="#python-1">python</a></li>
    </ul>
  </li>
  <li><a href="#section-2">对象类型转化</a>    <ul>
      <li><a href="#c-2">C++</a></li>
      <li><a href="#go-2">go</a></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>很多语言中有或严格或非严格的变量类型要求，而实际的编码的过程中，又难免需要一定的类型转换。</p>
</blockquote>

<h2 id="section">数字转字符串</h2>
<p>数字转字符串或字符串转数字，是比较常见的类型转换。
### C/C++</p>

<pre><code># include &lt;stdio.h&gt;
# include &lt;stdlib.h&gt;
void main (void){
    int num = 100;
    char str[25];
    itoa(num, str, 10);
}
</code></pre>

<p>C语言提供了几个标准库函数，可以将任意类型(整型、长整型、浮点型等)的数字转换为字符串，下面列举了各函数的方法及其说明。</p>

<p>● itoa()：将整型值转换为字符串。
● ltoa()：将长整型值转换为字符串。
● ultoa()：将无符号长整型值转换为字符串。
● gcvt()：将浮点型数转换为字符串，取四舍五入。
● ecvt()：将双精度浮点型值转换为字符串，转换结果中不包含十进制小数点。
● fcvt()：指定位数为转换精度，其余同ecvt()。</p>

<h3 id="c">C++</h3>
<p>to Char*</p>

<pre><code>char str[10];
int a=123;
sprintf(str,"%d",a);
</code></pre>

<p>或用指针操作，存放信息，没有实际放在字符串中。</p>

<pre><code>*((int *)str) = a;
printf("%d\n", *((int *)str));
</code></pre>

<p>to string</p>

<pre><code>#include &lt;sstream&gt;
#Include &lt;string&gt;
string num2str(double i){
    stringstream ss;
    ss&lt;&lt;i;
    // ss.c_str(); // to char*
    return ss.str();
}
</code></pre>

<h3 id="python">python</h3>

<pre><code>int a = 123
str = str(123)
</code></pre>

<h3 id="go">go</h3>

<pre><code>import (
  "fmt"
"strconv"
)
function main() {
    a := 123
    f := 12.3
    str := strconv.Itoa(a)
    fmt.Println("%s\n",str)
    str = strconv.FormatFloat(a,'f', -1, 64)
    fmt.Println("%s\n",str)
    str = toString(a)
}
</code></pre>

<h3 id="shell">shell</h3>

<p>bash shell中没有明确的数字和字符串之分，但是在一些进行判断的时候，需要小心，这里不多描述。      </p>

<h2 id="section-1">字符串转数字</h2>
<p>### C/C++</p>

<pre><code>char str[]="123";
int a;
sscanf(str,"%d",&amp;a);

// or
a = atoi(str);
</code></pre>

<p>注意是 char* 而不是 string</p>

<h3 id="c-1">C++</h3>

<pre><code>istringstream stream1;
string string1 = "25";
stream1.str(string1);
int i;
stream1 &gt;&gt; i;
</code></pre>

<h3 id="go-1">go</h3>

<pre><code>str := "123"
a,error := strconv.Atoi(a)
</code></pre>

<h3 id="python-1">python</h3>

<pre><code>str = "123"  
a = int(str)
</code></pre>

<h2 id="section-2">对象类型转化</h2>

<h3 id="c-2">C++</h3>
<p>static_cast<br />
 最常用的类型转换符，在正常状况下的类型转换，如把int转换为float，如：int i；float f； f=（float）i；或者f=static_cast<float>(i);</float></p>

<p>const_cast<br />
  用于取出const属性，把const类型的指针变为非const类型的指针，如：const int *fun(int x,int y){}　　int *ptr=const_cast&lt;int *&gt;(fun(2.3))</p>

<p>dynamic_cast</p>

<p>该操作符用于运行时检查该转换是否类型安全，但只在多态类型时合法，即该类至少具有一个虚拟方法。
dynamic_cast与static_cast具有相同的基本语法，dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。
在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。</p>

<p>reinterpret_cast<br />
interpret是解释的意思，reinterpret即为重新解释，此标识符的意思即为数据的二进制形式重新解释，但是不改变其值。</p>

<p>网上的介绍还是比较多的 <a href="http://blog.chinaunix.net/uid-25132162-id-2938837.html" target="_blank">C++中类型转换</a>、
<a href="http://www.cnblogs.com/goodhacker/archive/2011/07/20/2111996.html" target="_blank">C++类型转换总结</a>、
<a href="https://technet.microsoft.com/zh-cn/magazine/hh279667.aspx" target="_blank">类型转换和类型安全（现代 C++）</a>。</p>

<h3 id="go-2">go</h3>
<p>为了适应出现的各种情况，go中经常定义返回的接口为 <code>[]interface{}</code>，如果我们已经能确定里面的类型是int、或string类型时，如何转换。</p>

</div>
        <div class="more text-right"><a href="/2015/04/07/%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2.html">继续阅读全文</a></div>
    </div>
    
</div>

<div class="nav-post-links">
        
        <span class="newer-posts-link">
            
                <a href="/page2" title="previous page">&laquo; Newer Posts</a>
            
        </span>
        

        
        <span class="older-posts-link">
            <a href="/page4" title="next page">Older Posts &raquo;</a>
        </span>
        
</div>

                    </div>
                    <div class="col-md-3" id="main-right">
                        <div>
    <h4><strong>文章分类</strong></h4>
    <hr class="small-margin colored-hr" />
    <ul class="side-cat-ul">
        
        <li><a href="/categories.html#cat-生活随记" title="生活随记">生活随记 (3)</a></li>
        
        <li><a href="/categories.html#cat-bigdata" title="bigdata">bigdata (9)</a></li>
        
        <li><a href="/categories.html#cat-web" title="web">web (9)</a></li>
        
        <li><a href="/categories.html#cat-database" title="database">database (3)</a></li>
        
        <li><a href="/categories.html#cat-linux" title="linux">linux (10)</a></li>
        
        <li><a href="/categories.html#cat-go" title="go">go (8)</a></li>
        
        <li><a href="/categories.html#cat-运维" title="运维">运维 (3)</a></li>
        
        <li><a href="/categories.html#cat-language" title="language">language (7)</a></li>
        
        <li><a href="/categories.html#cat-tools" title="tools">tools (1)</a></li>
        
        <li><a href="/categories.html#cat-iot" title="iot">iot (5)</a></li>
        
    </ul>
</div>

<hr class="small-margin colored-hr" />

<!-- google adsense -->
<!--
<div>
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <ins class="adsbygoogle"
        style="display:inline-block;width:300px;height:600px"
        data-ad-client="ca-pub-1339945837472110"
        data-ad-slot="8220828081"></ins>
    <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
</div>
-->


                    </div>
                </div>
            </div>

            <div id="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <hr class="colored-hr" />

                <p class="text-center">
                Copyright 2014 - 2016 | Gen time&#58; 2016-04-12 01:51:47 CST

                <!-- cnzz -->
                

                </p>


            </div>
        </div>
    </div>
    <div style="display:none;" class="back-to" id="toolBackTop">
        <a title="返回顶部" onclick="window.scrollTo(0,0);return false;" href="#top" class="back-top">返回顶部</a>
    </div>

    <!-- google analytics -->
    


</div>

    </body>
</html>
