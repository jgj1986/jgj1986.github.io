---
title: c++ 代码笔记
date: 2015-06-09 14:12:28
tags: Language
- a
- b
---

* toc 
{:toc}

>摩羯存储中有很多技巧性很高的代码，此处只是一些笔记。

## epoll
epoll和select的区别网上讨论的很多，计划后续再整理篇博客，加上与libevent的比较。  
唠叨两句epoll的知识点，主要是三个函数：

    int epoll_create(int size);
    int epoll_ctl(int epfd, intop, int fd, struct epoll_event *event);
    int epoll_wait(int epfd,struct epoll_event * events,int maxevents,int timeout);
    
而在代码中使用了ae_epoll.c，可以参考[redis中ae_epoll.c的源代码](http://www.cnblogs.com/liuhao/archive/2012/05/16/2505491.html){:target="_blank"}，对aeEventLoop做了调整：

    typedef struct {
        Conn* conns[AE_SIZE];
        int fired[AE_SIZE];
        int nready;
        void *apidata;
    } aeEventLoop;

定义使用函数，并且影响使用方法

    public：
    
        aeEventLoop *loop() {
            return &m_loop;
        }
        ...
    Private:
        aeEventLoop m_loop;
    
        ...
    server->loop()->conns[fd] = c;

在初始化是，结构体成员conns中每个元素的下标为连接的文件描述符，元素则为连接，如:

    Conn* c = conn_new(fd, ...);
    server->loop()->conns[fd] = c;
    
在epoll_wait得到的连接的文件描述符，从而可以得到连接的conn。

    eventLoop->fired[j].fd = e->data.fd;
    int fd = server->loop()->fired[j];
    Conn *c = server->loop()->conns[fd];

当有数据到来时，借用epoll的实现机制，callback的方式处理。
    
    callback = server->conf().callback();
    if (callback) {
        Status status = callback(c);
    ...
    
处理完这儿接收的数据格式之后，可能还有别的数据(如不符合规范的数据)，对于这样的数据，再次获取后处理。

## callback函数

此处想达到这样一个目的，根据接收到命令的不同由不同的函数处理，而不希望采用类似 `switch`的语句来实现。这里就有段比较精妙的代码：

    // 定义处
    // in class
    typedef int(Executor::*cmd_handler_t)(const Request& req, Response* res);
    struct command_t {                          
        std::strin      key;      
        handler_t       _handler; 
    };
    typedef std::map<std::string, command_t> command_map_t;
    const Executor::command_map_t Executor::s_commands = set_commands();
  
    Executor::command_map_t Executor::set_commands() {
        command_map_t commands;
        command_t set = {"SET0", &Executor::_set_value};
        command_t get = {"GET0", &Executor::_get_value};
    
        commands.insert(std::make_pair("SET", set));
        commands.insert(std::make_pair("GET", get));
        return commands;
    }
    
    int Executor::_set_value(const char* cmd, Request* request) {
        //...
    }
    int Executor::_get_value(const char* cmd, Request* request) {
        // ... 
    }
    int Executor::dispatch(Conn *c, const char* cmd, Request* request) {
        command_map_t::const_iterator cmd_it = s_commands.find(cmd);
        // if it not end
        int res = (Executor::_instance()->*cmd_it->second._handler)(cmd, response);
        // others
    }
    
    // 函数实现过程
    int callback(Conn *c) {
        //... read data from socket to buf
        Executor* executor = Executor::_instance();
        int res = executor->dispatch(c, buf, &request);
        //... back ret_data
        return res;
    }
    
    // 调用处
    // CLASS
    typedef int (*callback_func)(Conn *c);
    void Caller::set_callback(const callback_func& callback) {
        m_callback = callback;
    }
    //在类初始化时通过该方法设置
    // 调用  参考上一节最后代码段 

