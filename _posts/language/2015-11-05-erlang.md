---
title:  erlang 随笔
date: 2015-11-05 15:12:28 +0800
tags: language
- a
- b
---

* toc
{:toc}

## 编译
物联网WIFI很多情况下使用mqtt协议，现在开源的比较好的可能是emqtt，github上有[服务端](){:target="_blank"}和[客户端](){:target="_blank"}的代码。
但是尝试使用客户端例子的时候，却浪费了很长时间，主要原因是对erlang不熟悉。

1. 文件A.erl要使用文件B.erl文件的函数，其函数要expect出来。如果要直接使用，则应该是要有 *.beam文件，而不是 .erl 文件
2. 如果在同一个目录下可以不用做其他的引用，如果在不同目录下，则需要添加载入的搜索路径

    erl
    > code:add_pathz("/path/to/ebin").

    erl -pz /path/to/ebin
    >

add_pathz和pz加载到搜索的最后面，add_patha和pa加载到搜索的最前面。

## Supervisor

Erlang有四大behavior(`supervisor`、`gen_server`、`gen_fsm`、`gen_event`)，在阅读emqttd的源代码时，发现比较多的modules都是用start_child的方式启动的。大体方式如下：

    Servers = [{"emqttd ctl", emqttd_ctl}, 
        {"emqttd pooler", {supervisor, emqttd_pooler_sup}}, 
        {"emqttd broker", emqttd_broker},
        {"emqttd system monitor", emqttd_sysmon, emqttd:env(sysmon)}], 
    start_server(Sup, {Name, Server}) ->
    start_child(Sup, Server).
    start_server(Sup, {Name, Server, Opts}) ->
    start_child(Sup, Server, Opts).
    start_child(Sup, {supervisor, Module}) ->
    supervisor:start_child(Sup,
        {Module,{Module,start_link,[]},permanent, infinity, supervisor,[Module]}).
    start_child(Sup,{Module}) ->
    start_child(Sub, {Module,[]}).
    start_child(Sub,{Module,[Opts]})->
    supervisor:start_child(Sup,
        {Module,{Module,start_link,[]},permanent, 10000, worker,[Module]}).


start_child中有几个参数，网上的介绍也比较多了，此处只是说明，启动的类型只有`supervisor`和`worker`两种，只要没有实现supervisor behavior的进程都是worker。
    

