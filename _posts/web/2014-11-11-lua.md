---
title: lua
date: 2014-11-11 11:12:28 +0800
tags: web 
- a
- b
---

* toc 
{:toc}

lua 使用

> 现在做的项目，要提供一些小的http接口，负责与redis交互，日志文件的落地等。从配置、修改的简易上，决定使用ngix+lua，这个过程有幸接触到lua编程。里面的一些探索过程记录在此。关于nginx的安装配置，参考 [nginx install conf](http://blog.woshifengzi.com/2014/11/07/nginx-install-conf.html){:target="_blank"}。

##入门

网上关于lua的基本句法的介绍，很多都是对官网简介的翻译，可以很快在宏观上有个了解， 相比较而言[Progmming in Lua](http://www.lua.org/pil/){:target="_blank"}介绍的就比较详细，觉得理解起来不顺畅，也可阅读[中文版](http://wenku.baidu.com/link?url=nQcs7NfWfo0l_3L9lNT2aqAHTL2VrUgBdxCSQ4c8VlShzmfQSHs-H0Reje1gOutUtLRjBGCwr1XlEQEo4Dqj-3zWyPE0HSg6W__F0FeZaku){:target="_blank"}。

##类功能

###缘起

为实现日志落地，开发了一个初始化的类文件，有文件的打开、关闭，而打开的文件句柄设计为全局变量，这样在实际的操作函数中可直接使用该句柄，并能在特定情形下（下一小时），调用文件关闭函数将此文件关闭掉。当只落一种日志，每小时生成一个文件时，该设计比较没有问题。
可后来为了实现系统的监控功能，也设计实现个监控接口，将收到信息落地，此种情况下完全拷贝一份上面的代码也可以，但是代码重复了，比较丑陋。
为此，考虑使用常见的类，将需要的变量、函数放在类中，调用类的对象来实现。

###基础

参考网上资料，使用了lua的元表功能。对于元表的连接，参考了 [寰子的博客](http://blog.csdn.net/xocoder/article/details/9028347){:target="_blank"}。
引用如下， Lua查找一个表元素时的规则，其实就是如下3个步骤:

1.在表中查找，如果找到，返回该元素，找不到则继续
2.判断该表是否有元表，如果没有元表，返回nil，有元表则继续
3.判断元表有没有__index方法，如果__index方法为nil，则返回nil；如果__index方法是一个表，则重复1、2、3；如果__index方法是一个函数，则返回该函数的返回值

而元表和所谓是__index 是如何使用的呢？

    tableA.__index = tableA -- 把tableA的__index方法指向自己
    setmetatable(tableB, tableA)   --把B的metatable设置为A
    
###实现 

基于此，一个简单的lua类，就可以如博客 [lua学习：lua中“类”的实现](http://blog.csdn.net/losophy/article/details/20311387){:target="_blank"}

    A = {x=0,y=0}  
    --这句是重定义元表的索引，必须要有，  
    A.__index = A   
  
    --模拟构造体，一般名称为new()  
    function A:new(x,y)  
        local self = {}    
        setmetatable(self, A)   --必须要有  
        self.x = x    
        self.y = y   
        return self    
    end    
    function A:test()  
    print(self.x,self.y)  
    end  
  
    objA = A:new(1,2)  
    objA:test()  
    print(objA.x,objA.y)


## ngx_lua共享内存字典项

###配置

    http {
        ... 
        lua_shared_dict monitor_dict 1M;
        ...
    }
    
这样就定义了个字典项 access_dict，分配的内存大小为1M。

###使用

博客 [ngx_lua模块中的共享内存字典项API](http://blog.csdn.net/weiyuefei/article/details/38487475){:target="_blank"} 中列了很多字典项的接口，以及使用说明。目前自己的代码中只用到了add 和 delete，具体如下：

    -- 首先是使用这个共享内存
    local shared_dict = ngx.shared.monitor_dict
    local rotate_key = "monitor_log"
    while true do
        if cur_hour_level == monitor_log.hour then
            break
        else
            -- 这儿使用共享内存达到锁的目的
            -- 想shard_dict中天剑一个标识，1标示里面只能有一个这个的标识，10，标识当超过10s后没有成功就返回
            local ok, err = shared_dict:add(rotate_key, 1, 10)
            if not ok then
                ngx.sleep(0.01)
            else
                if cur_hour_level > monitor_log.hour then
                    monitor_log:close_file()
                    monitor_log:open_file()
                    if access_add_1_log_fo == nil then
                        nginx_exit("OpenFile Error")
                    end
                    monitor_log:hour_level_update(cur_hour_level)
                end
                --- 在共享内存中删除这个标识
                shared_dict:delete(rotate_key)
                break
            end
        end
    end




## cjson 使用

###缘起

实现了一个接口，接口返回为json格式的字符串。开始时候，使用的是默认的lua-json，用 ab 做压力测试时，发现相应速度一直提升不起来，而如果不适用json，速度就可以生气了。
网上看到的nginx和lua结合时，使用都是lua-cjson，于是换成用cjson，速度会有较大的提升

###安装

    $ wget http://www.kyne.com.au/~mark/software/download/lua-cjson-2.1.0.tar.gz
    $ tar zxf lua-cjson-2.1.0.tar.gz
    $ make && make install
    
在ubutun 12.04上安装的时候，提示没能找到 lua.h 文件，而已经安装了 lua5.1, liblua5.1-dev。查看vim，include的路径是 /usr/local/include下，将其换成 /usr/include/lua5.1下即可了

###使用
直接给出一段代码：

    local json = require("cjson")
    local json_content = json.decode(ret_msg)
    json_content["ret"] = false
    json_content["msg"] = msg
    ngx.say(json.encode(json_content))    

生成带有嵌套逻辑的json

    local data = {}
    data["area"] = area
    data["sex"] = sex
    data["birthday"] = birthday
    local ret = {}
    ret["statsus"] = 0
    ret["msg"] = ""
    ret["data"] = data      ---result as  "data": {"area":"", ...}
    local cjson = require "cjson"
    ngx.say(cjson.encode(ret)) 

    
    
##操作memcache

###安装与配置

假设已经有可以直接使用的memcache服务了(192.168.1.135:11211) ，此处只是对lua-resty-memcached的使用说明

    $ git clone https://github.com/openresty/lua-resty-memcached.git
    $ cat ngx.conf
    http {
         ...
        lua_package_path "/path/to/lua-resty-memcached/lib/resty/?.lua;;";  
        #
        server {
        ...
        }
    }

    
### 使用

一个尝试通lua-resty-memcached访问memcache的简单例子

    ngx.header.content_type = 'text/html; charset=utf-8';
    local memcached = require("memcached")
    --此处尝试用require("resty.memcached")，失败。应该在在上面的配置中，路径已经到了 ?.lua
    local memc, err = memcached:new()
    if not memc then
        ngx.say("failed to instantiate memc: ", err)
        ngx.exit(701)
    end
    
    local ok, err = memc:connect("192.168.1.135", 11211)
    if not ok then
        ngx.say("failed to connect mem", err)
        ngx.exit(701)
    end

    local res, flags, err = memc:get("key1")
    if err then
        ngx.say("failed to get key1")
        ngx.exit(701)
    end

    ngx.say(res)

[agentzh的git](https://github.com/openresty/lua-resty-memcached){:target="_blank"}上提供了更加详细的命令说明

### 优化

将创建memcached、mem的连接放在这一个lua的文件中，每次有请求到来，nginx都要去创建memcache，建立连接，使用 ab 做压力测试的时候，发现性能比较低。
做优化，将memc的初始化和与memcache的连接放在 ngx的初始化文件中。实际请求时，直接调用memc:get()方法。做压力测试，在理想的性能要求内。

