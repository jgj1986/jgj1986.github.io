---
title: netty
date: 2014-11-04 19:12:28 +0800
tags: web
- a
- b
---

* toc 
{:toc}


> 在[liveoak](www.liveoak.io){:target="_blank"}源代码的过程中，发现了使用netty，为了更加了解，参考 [官网文档](http://netty.io/wiki/user-guide-for-4.x.html){:target="_blank"} 。
本来期待的是能在liveoak的基础上实现所需要的功能，但是否来被否决了。就将看的一些笔记记录在此，以后找个时间翻译下这个官网文档。  

官网文档上提供了几个比较典型的例子:    

* [discard](dhttp://netty.io/4.0/xref/io/netty/example/discard/package-summary.html){:target="_blank"}  
* [echo](http://netty.io/4.0/xref/io/netty/example/echo/package-summary.html){:target="_blank"}   

里面的几个函数，可能会用到  

* echo例子中，writeAndFlush() = write() and flush()  
* time例子中，channelActive替代channelRead   

总体来说，有server端，有client端，而对里面的一些逻辑处理，都使用了XXHandler的代码。server端和client端的一些不同之处： 


<table>
<thead>
    <tr> 
        <th>server</th>
        <th> clinet</th>
    </tr>
</thead>
<tbody>
    <tr> 
        <td>ServerBootstrap</td>
        <td>Bootstrap</td>
    </tr>
    <tr> 
        <td>group(bossGroup, workerGroup) </td>
        <td> group(group)</td> 
    </tr>
    <tr> 
        <td>NioServerSocketChannel.class </td>
        <td>NioSocketChannel.class</td> 
        </tr>
    <tr> 
        <td>b.bind(PORT).sync() </td> 
        <td>b.connect(HOST, PORT).sync()</td>
    </tr>
</tbody>
</table>  


文档接下来探讨数据流的分割   

* 方案1、预先知道两端传输的字节流的长度，用buf.readableBytes()来保证接收到了足够的数据  
* 方案2、使用多个handler来实现  
