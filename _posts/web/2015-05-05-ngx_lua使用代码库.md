---
title: ngx_lua使用代码库
date: 2015-05-05 10:12:28
tags: web
- a
- b
---

* toc 
{:toc}

>使用ngx_lua重构服务端接口时，用到加密、解密算法，原来使用C来实现，有很多的位操作，使用lua来重构会比较麻烦，不如直接用使用C库形式。在开发过程中，有一些基础的函数，会在多个地方调用，通过库的形式调用，会更加优雅一些。

##lua调用C函数
参考 [Step By Step(Lua调用C函数)](http://www.cnblogs.com/stephen-liu74/archive/2012/07/23/2469902.html){:target="_blank"}，此处只是做简单说明。

    #include <stdio.h>
    #include <string.h>
    #include <lua.hpp>
    #include <lauxlib.h>
    #include <lualib.h>
    static int add(lua_State* L) {         // 以栈的形式传递参数
        double op1 = luaL_checknumber(L,1);  // 1表示Lua调用时的第一个参数(从左到右)，依此类推
        double op2 = luaL_checknumber(L,2); 
        lua_pushnumber(L,op1 + op2);                 // 将函数的结果压入栈中。如果有多个返回值，可以在这里多次压入栈中
        return 1;
    }
    static luaL_Reg testLibName[] = {           // luaL_Reg结构体的第一个字段为字符串，在注册时用于通知Lua该函数的名字
    {"add", add},
    {NULL, NULL}                                                // 结构体数组中的最后一个元素的两个字段均为NULL，用于提示Lua注册函数已经到达数组的末尾
    };
    // 其函数名必须为luaopen_xxx，其中xxx表示library名称。Lua代码require "xxx"需要与之对应
    int luaopen_testLibName(lua_State* L){ 
    const char* libName = "testLibName";
    luaL_register(L,libName,testLibName);  // 需要强调的是，所有需要用到"xxx"的代码，不论C还是Lua，都必须保持一致，这是Lua的约定
    return 1;
    }

为了方便，通过Makefile文件执行编译：

    ##### Build defaults #####
    LUA_VERSION =       5.1
    TARGET =            test.so
    PREFIX =            /usr/local/luajit
    CFLAGS =            -O3 -Wall -pedantic -DNDEBUG
    CJSON_CFLAGS =      -fpic
    CJSON_LDFLAGS =     -shared
    LUA_INCLUDE_DIR =   $(PREFIX)/include/luajit-2.0
    LUA_CMODULE_DIR =   $(PREFIX)/lib/lua/$(LUA_VERSION)
    LUA_MODULE_DIR =    $(PREFIX)/share/lua/$(LUA_VERSION)
    LUA_BIN_DIR =       $(PREFIX)/bin

    BUILD_CFLAGS =      -I$(LUA_INCLUDE_DIR) $(CJSON_CFLAGS)
    OBJS =               test.o

    .PHONY: all clean
    .c.o:
    $(CC) -c $(CFLAGS) $(CPPFLAGS) $(BUILD_CFLAGS) -o $@ $<
    all: $(TARGET)
    
    $(TARGET): $(OBJS)
    $(CC) $(LDFLAGS) $(CJSON_LDFLAGS) -o $@ $(OBJS)
    clean:
    rm -f *.o $(TARGET)
  
在ngx_lua中使用，将生成的 test.so 放在特定的目录下，nginx.conf 以类似 `lua_package_cpath '/usr/local/nginx_lua/lua_so/?.so;;';` 的形式包含，
参考[nginx与lua的安装教程](http://blog.kissdata.com/2014/11/14/nginx-lua-install.html){:target="_blank"}。  
上面使用 `lua_pushnumber`函数，在实际的过程中，使用的可能是 `lua_pushlstring`，更多的函数，
可以查阅 [lua 参考手册](http://www.codingnow.com/2000/download/lua_manual.html){:target="_blank"}

##基础函数
实际编码过程中，会有一些逻辑，在多个地方被调用。采用基础函数的方式来实现，是比较好的选择。而其实现，也有几种方式

###初始化函数
nginx.conf 的 http 模块中，通过 `init_by_lua_file /path/init.lua;` 的方式配置初始化文件，在nginx启动时，
会将文件中的内容(变量、函数、共享内存)等加载到内存，在整个nginx运行过程中均可以被使用。文件中内容为全局的，可直接使用变量、函数。  
但是init文件只能有一个，如果太多的东西都塞进来，文件会比较冗长，阅读不方便，且一致占用内存

###库函数
通过`lua_package_path '/path1_to/lua_so/?.lua;/path2_to/?.lua;';` 的方式指定路径。有 com.lua 文件如下

    local null = ngx.null
    local unpack = unpack
    local setmetatable = setmetatable

    local _M = { _VERSION = '0.1' }
    local mt = { __index = _M }

    function _M.new(self)
    math.randomseed(os.time())
    return setmetatable({}, mt)
    end

    function _M.genReturnTable(self,a)
    local obj = {}
    obj.dtl = "ok"
    obj.str = a
    return obj
    end
    function _M.testFun(self, a)
        -- check a !
        -- when call inner function, user _M.xx(self, ...)
        return _M.genReturnTable(self, a)
    end
    
    return _M

在使用调用内容，则如下

    local com = require("com")
    com.testFun("testStr")
    
注意，对于lua类方法的调用，则要用`:`    
