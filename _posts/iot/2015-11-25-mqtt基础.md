---
title:  mqtt基础
date: 2015-11-25 18:12:28 +0800
tags: iot
- a
- b
---

* toc
{:toc}

> 今天北京风大天冷 :-)  本文是对HiveMQ上[MQTT基础要点系列文章](http://www.hivemq.com/blog/mqtt-essentials/){:target="_blank"}的阅读笔记。过程中有一些疑惑地方，但是还没有及时的实践。


## MQTT的介绍

轻量、开源、简单等，特点，以及历史、版本等 :-)

## 发布&订阅

[原文](http://www.hivemq.com/blog/mqtt-essentials-part2-publish-subscribe){:target="_blank"}。

pub、sub的模式实现空间、实践、同步上的解耦，从而具有很好的可扩展性；对于消息，支持基于对象、内容、类型的过滤；与消息队列是不同的，后者被消费前会一直保存，且消息只能被一个客户取的，队列名称要事先创建好。

问题：对于后面说到的内容、类型的消息过滤，应该实际的使用体验下。

## Client&Broker 以及连接的建立

[原文](http://www.hivemq.com/blog/mqtt-essentials-part-3-client-broker-connection-establishment){:target="_blank"}。

Client&Broker的基本功能，值得一提的是，broker还要有监控订阅功能。MQTT的连接，底层是基于TCP/IP协议的，该过程中client对发送一个 `CONNECT`的消息，收到一个`CONNACK`的响应消息。

CONNECT Message
    
    contains:   Example
    clientId    "client-1"
    cleanSession    true 
    username    "jgj"       (optional)
    password    "nopassword"    (optional)
    lastTopic   "/jgj/will" (optional)
    lastWillQos 2       (optional)
    lastWillMessage "unexpected exit" (optional)
    keepAlive   60

clientId 用来标识客户端，所用同一个clientId被两次使用的时候，第二次的会将第一次的给覆盖。  
新了解的是 `Clean Session`，对应设置后续章节中的 `persistent session`。  
`lastWillXX`的相关信息，会在 `Last Will` 章节中有具体的说明。

CONNACK Message
    
    contains:   Example
    sessionPresent  false
    returnCode  0

不同的结果会在returnCode中表现出来。

## MQTT的Pub,Sub & UnSub

[原文](http://www.hivemq.com/blog/mqtt-essentials-part-4-mqtt-publish-subscribe-unsubscribe){:target="_blank"}。

PUBLISH
    packetId    4314
    topicName   "topic/1"
    qos     1
    retainFlag  false
    payload     "blabla"
    dupFlag     false

介绍pub/sub的一些基本过程、请求时的包，值得一提的是：Publish包中包含字段 retainFlag，在后面章节 retainedMessage专门介绍。还有个字段 packetId，当qos为0时，取值多为0，其他情况，不知道是不是会按照一定的规则生成一个。sub时，请求发送`SUBSCRIBE`信息，返回`SUBACK`信息；取消订阅 unsub时，发送`UNSUBSCRIBE`信息，返回`UNSUBACK`信息。

## Topic 及最佳实践

[原文](http://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-topics-best-practices){:target="_blank"}。

Topic最好名称数字和字码，中间可以用 `/` 来分隔，开头不要是 `/`。支持统配符， `+` 只匹配单个字段，`#` 可以匹配多个，如下

    myhome/groudfloor/+/temperatur
    myhome/groudfloor/liveroom/temperatur  # 匹配
    myhome/liveroom/temperatur         # 不匹配
    myhome/groudfloor/liveroom/fridge/temperatur  # 不匹配

    myhome/groudfloor/#
    myhome/groudfloor/temperature   # 匹配
    myhome/groudfloor/livingroom/temperature # 匹配
    myhome/firstfloor/temperatur    # 不匹配

按照约定，以`$`符号开头的Topic一般会认为是特殊的topic，为Broker内部统计所保留的。虽然没有明确的规定，但是参考MQTT GutHub wiki上的建议，一般会有这样的一些例子

    $SYS/broker/clients/connected
    $SYS/broker/clients/disconnected
    $SYS/broker/clients/total
    $SYS/broker/messages/sent
    $SYS/broker/uptime

最后对Topic的命名有一些建议，

. 不要以`/` 开头   
. 不要用空格   
. 命名简洁  
. Ascii字符，避免使用特殊字符  
. 包含clientid或唯一标识符  

## QOS

[原文](http://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels){:target="_blank"}。

QOS: Quality of Service。 
. 0:最多一次，请求之后就结束了  
. 1:最少一次，请求后存储message，等待返回消息PUBACK用于确认；若一定时间内没有收到，则再次发送  
. 2:只有一次，sender pub消息后，broker返回`PUBREC`；sender收到返回收再次发送`PUBREL`，broker会保留消息知道返回`PUBCOMP`   

qos2安全但是比较慢。

疑问： 如果使用QOS1或者2，publish消息后，broker收到了，但是没有订阅者，那发布者分别会有怎样的情况。


##  Persistent Session and Queuing Messages

[原文](http://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels){:target="_blank"}。

标题应该怎么翻译呢，持续的回话和队列，大体就是这个意思了。这个是干什么用的呢，就是会有这样的一些场景，当新的订阅者连到Topic，或者是重新连接到Topic后，以前的消息还想按照顺序都得到。
如何设置呢，在前面介绍已经提到，连接的建立时通过字段 cleanSession 来设置，而且连接连接时的返回字段中也会告知是否是 persistent 的session。

以后用到了，在对这个地方好好说明。

## 保留消息

[原文](http://www.hivemq.com/blog/mqtt-essentials-part-8-retained-messages){:target="_blank"}。

应用的场景：当新的client端连接到topic时，不知道当前的状态是怎么样，如果发布者很久不发布新的状态，那新client就要一直等着或设置为不合理的默认状态。使用RetainedMessage，会保留最后的状态，新的client连接上之后，就会有最新的状态了。

如果设置呢？上面提到，Publish的时候，通过retainFlag字段来设置。

## LastWill

[原文](http://www.hivemq.com/blog/mqtt-essentials-part-9-last-will-and-testament){:target="_blank"}。

应用的场景：当一些连接不优雅的断掉后，其他保持连接的订阅客户端也要收到信息，从而有相应的处理。  
设置：在建立连接时，通过LastWillTopic、LastWillQos、LastWillMessage字段来设置，而且多和retainedMessage一起使用。 

注意：是pub不优雅的断掉，订阅端收到信息。而如果是优雅的断开，保存的信息会丢弃。

问题: LastWillTopic和Client用到的Topic是不是同一个Topic，还是所有的LastWillTopic使用同一个？

## 保持连接和客户端接管

[原文](http://www.hivemq.com/blog/mqtt-essentials-part-10-alive-client-take-over){:target="_blank"}。

保持连接的必要性，流程：请求 PINGREQ，返回 PINGRESP；规定时间的3/2 时间内断开。

如果在client端连接断开，请求重连，而broker的之前的连接还没有断开，那么broker会关闭之前的连接到现在的新连接。


## 总结

这系列的文章对深入一些了解mqtt的基础、用户有非常好的帮助。应该多看看原文。

