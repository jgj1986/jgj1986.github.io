---
title:  mqtt中使用ssl
date: 2015-11-17 18:12:28 +0800
tags: iot
- a
- b
---

* toc
{:toc}

> 本文为mqtt中使用ssl的笔记，这个过程中尝试了很多中方法，只为找到行之有效的方式。

## mosquitto 尝试

为什么样用mosquitto来尝试？因为在使用emqttd的时候出现了问题，emqttd的资料相对比较少，于是决定先用mosquitto. 下载[mosquitto源码](http://mosquitto.org/files/source/mosquitto-1.4.5.tar.gz){:target="_blank"}，解压后执行`make`，得到可执行代码。
    
修改配置文件，添加使用tls的证书文件。因为开始不知道具体应该如何使用证书文件，于是按照 [自建ssl](http://blog.woshifengzi.com/2015/11/17/%E8%87%AA%E5%BB%BAssl.html){:target="_blank"}的方式创建的 `ca.crt`, `server.crt`,`server.key`

    listener 8883
    cafile /path/to/ca.crt
    certfile /path/to/server.crt
    keyfile /path/to/server.key

启动服务

    ./mosquitto -c /path/mosquitto.conf

服务端启动后，可以看到已经在监听8883端口了，emqttc也支持ssl的方式，而paho的文档看着更加详细，所以计划使用后者。

pub代码如下:

    ...
    tls_dict = {'ca_certs':'/path/to/server.crt'}
    publish.single("TopicA", payload="test", qos=0,hostname="localhost", port=8883, tls=tls_dict)
    
执行时emqttd端没有反应，pub端有很多错误输出。

      File "/usr/lib/python2.7/ssl.py", line 381, in wrap_socket         
        ciphers=ciphers)                                                 
      File "/usr/lib/python2.7/ssl.py", line 141, in __init__            
        ciphers)                                                         
    TypeError: an integer is required     

同时服务端也报错：

    OpenSSL Error: error:140780E5:SSL routines:SSL23_READ:ssl handshake failure
    Socket error on client <unknown>, disconnecting.

## 查找原因

首先定位 mosquitto 的tls，在[官网上](https://eclipse.org/mosquitto/man/mosquitto-tls-7.php){:target="_blank"}看到有这样的提示：

    It is important to use different certificate subject parameters for your CA, server and clients. If the certificates appear identical, even though generated separately, the broker/client will not be able to distinguish between them and you will experience difficult to diagnose errors.

于是尝试重新生成一份 client.crt 和 client.key，在paho中使用client的证书，仍然如此。在 [bug-1221285](https://bugs.launchpad.net/mosquitto/+bug/1221285){:target="_blank"}的讨论中，看到使用自带的证书和mosquitto_sub命令，于是在源码的client端找到工具，
    
    ./mosquitto_sub -h localhost -p 8883 -t TopicA --cafile /path/to/mosquitto/test/ssl/test-root-ca.crt

    ./mosquitto_pub -h localhost -p 8883 -t TopicA --cafile /path/to/mosquitto/test/ssl/test-root-ca.crt -m "test"

pub正常，而且sub也收到了消息，也就是说用这里的证书ok。此时继续用上面说到的 paho ，将证书做修改为此处的证书，仍然有同样问题，看到paho端最后提示是一个类型错误，于是尝试使用如下

    tls_dict = {'ca_certs':'/path/to/mosquitto/test/ssl/test-root-ca.crt',
            'certfile':'/path/to/mosquitto/test/ssl/client.crt',
            'keyfile':'/path/to/mosquitto/test/ssl/client.key',
            'tls_version':ssl.PROTOCOL_TLSv1} ## 添加此行
    
    publish.single("TopicA", payload="newtest", qos=0,hostname="localhost", port=8883, tls=tls_dict)

于是正常了！


## emqttd 初试

基于上面的经验，在用eqmttd，配置文件emqttd.conf就直接使用上面已经验证过的证书文件

    ...
    {emqttd, [
      {access, [
        {auth, [
            {anonymous, []}
        ]},
       ...
       {listeners, [
        {mqtts, 8883, [
        %% Size of acceptor pool
        {acceptors, 4},
        %% Maximum number of concurrent clients
        {max_clients, 512},
        %% Socket Access Control
        {access, [{allow, all}]},
        %% SSL certificate and key files
        {ssl, [{certfile, "/path/to/server.crt"},
                   {keyfile,  "/path/to/server.key"}]},
        %% Socket Options
        {sockopts, [
                    {backlog, 1024}
                    %{buffer, 4096},
                ]}
            ]},
        ...
        ]},
    ...

服务端重启后，可以看到已经在监听8883端口了，使用 paho测试，得到错误信息

    error:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed 

## emqttd 解决

看来是两个实现方式对证书的要求还不一样，做如下测试

    tls_dict = {'ca_certs':'/home/work/mosquitto/test/ssl/test-root-ca.crt',
        'tls_version':ssl.PROTOCOL_TLSv1}                

    publish.single("TopicA", payload="newtest", qos=0,hostname="localhost", port=8883, tls=tls_dict)

还继续有同样的问题，改为

    
    tls_dict = {'ca_certs':'/home/work/mosquitto/test/ssl/all-ca.crt',
        'tls_version':ssl.PROTOCOL_TLSv1}                

    publish.single("TopicA", payload="newtest", qos=0,hostname="localhost", port=8883, tls=tls_dict)

成功！！

也就是说emqttd要求，服务端使用server的crt和key，客户端在使用的时候，直接提供证书即可，这和常见的https的方式比较一致。  

## 后续

使用自己生成的ca.cert, server.crt, server.key做测试
