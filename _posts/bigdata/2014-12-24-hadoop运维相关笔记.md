---
title:  hadoop 运维相关笔记
date: 2014-12-24 21:12:28 +0800
tags: bigdata
- a
- b
---

* toc 
{:toc}


Hadoop的安装，此处不做过多介绍。只是说在使用hadoop过程中一些运维的事情。

### datanode无法停止
经常遇到这样情况，使用 `jps` 命令查看进程，发现 datanode 还在，但是使用命令，

    $ ./sbin/hadoop-daemon.sh stop datanode
    no datanode to stop
    $

却提示datanode进程不在， 是什么原因呢？
使用命令
    
    ./bin/hadoop dfsadmin -report
    
可以报告各个节点的状态信息。报告中的各个节点也在，使用上面的stop命令停止节点时，仍然是提示进程不在。  
原来是保存 datanode.pid的文件被换了。默认的文件会在 `/tmp/hadoop-USER-datanode.pid` 中，这个时候，查看 /tmp/hadoop*会有比较多的文件。  
因为默认 /tmp 路径下的文件会经常被修改、删除等，所以将这些文件放在 /tmp目录不够安全，可以修改该进程号存放的路径。

    cat etc/hadoop/mapred-env.sh
    ...
    #export HADOOP_MAPRED_PID_DIR= # The pid files are stored. /tmp by default.
  export HADOOP_MAPRED_PID_DIR=/path_to/data/hdfs/pid
  
参考 [hadoop常见问题(2).no datanode to stop](http://blog.sina.com.cn/s/blog_6d932f2a0101fsxn.html){:target="_blank"}。

什么情况会导致产生别的datanode.pid的文件呢。查看datanode的log，发现会报一些错误，导致datanode被强制或错误的关掉了。

### Bad connect 

运行mapreduce、上传、下载hadoop文件时，会提示 bad connect，如下：

    14/12/21 17:02:26 INFO hdfs.DFSClient: Exception in createBlockOutputStream
    java.io.IOException: Bad connect ack with firstBadLink as 10.10.12.168:50010

这个和上面是同一个原因，是对应的datanode被关闭导致的。但是是什么原因导致的关闭呢？datanode日志报错:

发现有161上如下错误：

参考 [hadoop的datanode异常结束](http://blog.csdn.net/joomlaer/article/details/16801717){:target="_blank"}，是因为有坏的磁盘导致的。
可在在hdfs-site.xml里屏蔽掉坏磁盘。  
如何检测坏的磁盘， `hadoop fsck /` 可以么？

参考别的资料，配置 hdfs-site.xml 中的 `dfs.datanode.socket.write.timeout`，尝试将timeout的时间调长些。

###配置优化
* noatime的设置  
为了充分发挥性能，需要使用noatime选项挂载磁盘，表示执行读操作时，不更新文件的访问时间，可以显著提供性能。

* 缓冲区大小  
io.file.buffer.size默认是4KB，作为hadoop缓冲区，读写hdfs的文件、map的输出都用到了这个缓冲区容量，可以设置为64KB(65536字节)或128KB(131072)(太大了map和reduce任务可能会内存溢出)。

* HDFS块大小  
默认大小64MB，可通过 hdfs-size.xml的dfs.block.size设为 128MB(134 217 728)或256MB(268 435 456)来降低namenode的内存压力！

* 保留存储空间  
dfs.databide.du.reserved属性来制定待保留的空间大小（字节为单位），避免将该磁盘空间用满！

###distcp
分布式复制, 能从hadoop的文件系统并行复制大量数据。

* src/aa 拷贝至 /dest/aa   
如果/dest/aa存在，则/src/aa拷贝成/dest/aa/aa; 如果/dest/aa不存在，则/src/aa拷贝成/dest/aa <br>

* /src/aa, /src/bb 拷贝至 /dest/aa   
无论/dest/aa存在或不存在，始终拷贝成/dest/aa/aa, /dest/aa/bb;/src/aa 更新/覆盖拷贝(-update/-overwrite) 至 /dest/aa;无论/dest/aa存在不存在，始终拷贝成/dest/aa<br>

* /src/aa, /src/bb 更新/覆盖拷贝至 /dest/aa   
同上，但是，如果/src/aa和/src/bb下有同名的文件，那么就会引起冲突，报错。
