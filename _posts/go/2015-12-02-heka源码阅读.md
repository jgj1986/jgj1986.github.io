---
title:  heka源码阅读
date: 2015-12-02 12:12:28 +0800
tags: go
- a
- b
---

* toc
{:toc}

>使用heka已经一段时间了，而里面的逻辑还是很有必要看看的。

## 大体流程 

    main (cmd/hekad/main.go)
     |  LoadHekadConfig (cmd/hekad/conf.go)
     |  setGlobalConfigs
     |  loadFullConfig
     |  LoadFromConfigFile (pipeline/config.go)
     |  Run(pipeline/pipeline_runner.go)
 
可以大体看出，加载配置文件，设置为一些全局的变量，生成相关的input、output、decoder、encoder、filter等，然后启动这些插件。

## 加载配置文件

加载配置文件，主要是将制定目录下的 .toml 文件 或制定的配置文件读到内存，先设置一些全局的配置如 cpu 等；然后逐个处理每个插件。

先做Pre-loading，判断插件是不是已经注册过的插件。这儿需要说明，使用 AvailablePlugins 来存放已经注册的插件，RegisterPlugin 函数实现后端的注册功能。 在Pre-Loading过程中，会将插件按照 Input、Output、Filter 等分到不同的组中，用于后面不同顺序启动。实际过程是调用 `NewPluginMaker` 来创建对应的插件制造者(PluginMaker)。

有两个特殊的插件 `ProtobufEncoder` 和 `ProtobufDecoder`，即使在没有配置的情况下也要启动。

接下来是Loading过程：分别去除 "Decoder", "Encoder", "Input", "Filter", "Output" 组中的pluginMaker，调用其 MakerRunner()得到相应的runner，放到不同的Runners组中。
在MakerRunner函数中，会根据类型的不同，生成不同的runner，如NewInputRunner、NewFORunner 等，这些构造函数在 pipeline/plugin_runners.go 中实现。需要说明的一点，在xxRunner的类型都定义了自己的函数，比如Start(调用Starter)函数会调用插件的 `Run`方法，所以在后续调用每个runner的Start 方法时，即调用了插件的Run方法。encode和decode插件，实现对应的Encode 和 Decode方法，而不是Run方法。

## 启动与关闭

pipeline_runner.go 中的 `Run`函数实现了heka的插件启动、监控、退出功能。

先依次启动 output、filter的插件，然后是一些heka自己的初始化，router.initMatchSlices、启动diagnostic trackers、config.router.Start，然后在启动input相关的插件。插件的启动，即调用插件的Start即Run方法。
插件都正常启动运行后，heka主线程就是等待退出信号，当有退出信号时，按照启动相反的顺序，停止 input、decode、filter、output、encode，即调用stop()方法。

## 数据的传递

该过程中，消息又是如何从 input一步步的传递到output中的呢？是什么要的机制保证heka能有如此高的传递速度的呢？

在 《go语言编程》中有实现管道的一段简单例子，

    type PipeData struct {
        value int
        handler func(int) int
        next chan int
    }
    
    func handle(queue chan *PipeData) {
        for data := range queue {
            data.next <- data.handler(data.value)
        }
    }

其基本逻辑也就是，在入口端接收到消息，做相应的处理后，写入到对应的下一个channel中。有了这样的基础知识，我们来看 `config.router.Start()` (pipeline/router.go)，有这样的一段实现

    select {
        case ...
        ...

            case pack, ok = <-self.inChan:
                if !ok {
                    break
                }
                pack.diagnostics.Reset()
                atomic.AddInt64(&self.processMessageCount, 1)
                for _, matcher = range self.fMatchers {
                    if matcher != nil {
                        atomic.AddInt32(&pack.RefCount, 1)
                        matcher.inChan <- pack
                    }
                }
                for _, matcher = range self.oMatchers {
                    if matcher != nil {
                        atomic.AddInt32(&pack.RefCount, 1)
                        matcher.inChan <- pack
                    }
                }
                pack.Recycle()
            }
    ...

也就是，当自己inChan中有数据到达的时候，会和matcher做判断，匹配的情况下，就会将数据传到matcher的 inChan 中，这样就将数据依次传递下去了。

在Encode和Decode中，使用的是指针的方式在函数间传递的，效率会比较高。

至于input插件的数据怎么来，output的数据怎么输出，就是插件按照自己的需求实现了。
