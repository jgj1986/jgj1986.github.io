---
title:  lex/yacc学习笔记
date: 2014-12-06 15:12:28 +0800
tags: linux 
- a
- b
---

* toc 
{:toc}

>项目开始时，要提供sql语句的查询功能，而后台的实现不是常规sql，计划实现个简单的sql功能，于是看到了lex、yacc

##简介

lex/yacc多用于编译器的开发，lex做词法解析，yacc做语法解析。可以看看 [The LEX & YACC Page](http://dinosaur.compilertools.net/){:target="_blank"}
 和 [Lex & Yacc Tutorial](http://epaperpress.com/lexandyacc/index.html){:target="_blank"} 。历史来源、理论等不做过多说明。
 
###编译工具
学习过程中，尝试在Linux上使用C语言的工具，lex使用工具 `flex`， yacc使用工具 `bison`。假设有文件 frame.l (lex文件) 和frame.y(yacc文件)，大致编译如下

    $ flex frame.l  #生成lex.yy.c
    $ bison frame.y #生成frame.tab.c和frame.tab.h
    $ gcc frame.tab.c lex.yy.c -o start
 
##lex 

###框架
lex代码框架形式如下

    ... 定义  ... 
    %%     
    ... 规则  ... 
    %% 
    ... 子程序  ...

通过 `%%` 将lex分为三部分。

###简单实例1
lex中可以通过正则表达式做匹配（对于正则表达式，此文不描述），结合其框架，我们先实现一个简单的实例，打印 是数字 还是 单词。
本实例来自 [Lex和Yacc入门](http://blog.csdn.net/djinglan/article/details/9263361){:target="_blank"}（其源出处已经404了，此处只好提供一个转发的地址了）

    %{
        #include <stdio.h>
    %}

    %%
    [0123456789]+           printf(“NUMBER\n”);
    [a-zA-Z][a-zA-Z0-9]*    printf(“word\n”);
    
上面定义处引用 `stdio.h`是为了使用里面的printf函数。注意这儿实现C功能的解析，所以该有 `;` 的地方还是不能少。假设文件名为 “print.l”，可以用如下命令编译，执行

    $ flex print.l
    $ gcc lex.yy.c -o print -ll
    $ ./print
    daa
    Word

    fadfadfafasddfasdfadsf
    Word

    234
    NUMBER

    dfa234
    Word 
    
-ll表示连接lex的库，在liblex中有main函数，所以上面print.l中没有main函数的情况下，还是可以运行。

###简单实例2
上面的例子给出一个可以运行的的代码，先建立了使用的信心；[lex/yacc的epp](http://epaperpress.com/lexandyacc/prl.html){:target="_blank"}上提供的一个实例能很好的描述lex的一些内在逻辑，如下：

    %{
        int nchar, nword, nline;
    %}
    %%
    \n         { nline++; nchar++; }
    [^ \t\n]+  { nword++, nchar += yyleng; }
    .          { nchar++; }
    %%
    int main(void) {
        yylex();
        printf("%d\t%d\t%d\n", nchar, nword, nline);
        return 0;
    }
    
此处代码使用lex中预定义的变量：

    int yylex(void)     调用扫描器,返回标记 
    char *yytext        指针,指向所匹配的字符串 
    yyleng              所匹配的字符串的长度 
    yylval              与标记相对应的值 
    int yywrap(void)    约束,如果返回 1 表示扫描完成后程序就结束了,否则返回 0 
    FILE *yyout         输出文件 
    FILE *yyin          输入文件 
    INITIAL             初始化开始环境 
    BEGIN               按条件转换开始环境 
    ECHO                输出所匹配的字符串

    
##yacc  

###框架
yacc代码框架形式如下

    ... 定义  ... 
    %%     
    ... 规则  ... 
    %% 
    ... 子程序  ... 
    
可以发现，yacc和lex的架构是一样的。YACC可以解析输入流中的标识符(token)，而这些标识符来自lex。

###简单实例1

假设有lex文件，其内容为：

    %{
        #include <stdio.h>
        #include "y.tab.h"
    %}

    %%
    [0-9]+                  return NUMBER;
    [a-zA-Z][a-zA-Z0-9]+    return WORD;
    %%
    
yacc文件中的代码：

    %{
    #include <stdio.h>
    #include <string.h>
    
    void yyerror(char *s) { 
        printf("%s\n", s); 
    }   

    int yywrap() {
        return  1;  
    }   

    int main() {
        yyparse();
        return 0;
    }   
    %}
    %token  NUMBER WORD

    %%
    commands: /* empty */
        | commands command
        ;

    command: target_word
        | target_num
        ;

    target_word:
    WORD {
        printf("\t yacc get word \n");
    }
    ;

    target_num:
    NUMBER {
        printf("\tyacc get number\n");
    }
    ;
    %%

编译执行测试：

    $ flex frame.l 
    $ bison -d y.y 
    $ gcc lex.yy.c y.tab.c -o test 
    $ ./test
    wdafs
        yacc get word 

    1234
        yacc get number

    dsfad134
        yacc get word 

lex通过正则匹配得到 `NUMBER` 和 `WORD`，在yacc中使用 `巴科斯范式`得到 NUMBER 和  WORD 并做处理。本实例只是一个非常简单的例子，得到后做一个打印输出，表明我得到了什么。


**后续，其他的几个yacc的实例，并对lex和yacc做一总结**
